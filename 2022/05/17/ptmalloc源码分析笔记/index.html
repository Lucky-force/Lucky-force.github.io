<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ptmalloc的设计概述ptmalloc内存管理的设计假设ptmalloc的设计假设是对于ptmalloc的基本行为概述，可以从宏观层面掌握ptmalloc在内存分配中采取的行为。    具有长周期的大内存分配使用mmap^1。 特别大的内存分配总是使用mmap。 具有短周期的内存分配使用brk。 尽量只缓存临时使用的空闲小内存块，对大内存或者长周期的大内存在释放时都直接还给操作系统。 对空闲的">
<meta property="og:type" content="article">
<meta property="og:title" content="ptmalloc源码分析笔记">
<meta property="og:url" content="http://example.com/2022/05/17/ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="L1m1t3r&#39;s Blog">
<meta property="og:description" content="ptmalloc的设计概述ptmalloc内存管理的设计假设ptmalloc的设计假设是对于ptmalloc的基本行为概述，可以从宏观层面掌握ptmalloc在内存分配中采取的行为。    具有长周期的大内存分配使用mmap^1。 特别大的内存分配总是使用mmap。 具有短周期的内存分配使用brk。 尽量只缓存临时使用的空闲小内存块，对大内存或者长周期的大内存在释放时都直接还给操作系统。 对空闲的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/images/chunk.PNG">
<meta property="og:image" content="http://example.com/images/images/malloc.png">
<meta property="og:image" content="http://example.com/images/images/free.png">
<meta property="og:image" content="http://example.com/images/images/bins.png">
<meta property="og:image" content="http://example.com/images/images/small_bins.png">
<meta property="og:image" content="http://example.com/images/images/ptmalloc_ini.png">
<meta property="article:published_time" content="2022-05-17T04:33:24.000Z">
<meta property="article:modified_time" content="2022-05-24T10:31:49.194Z">
<meta property="article:author" content="Limiter">
<meta property="article:tag" content="ctf,cs,pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/images/chunk.PNG">

<link rel="canonical" href="http://example.com/2022/05/17/ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ptmalloc源码分析笔记 | L1m1t3r's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">L1m1t3r's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">水水水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="Limiter">
      <meta itemprop="description" content="maybe ordinary people don't always crack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1m1t3r's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ptmalloc源码分析笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-17 12:33:24" itemprop="dateCreated datePublished" datetime="2022-05-17T12:33:24+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 18:31:49" itemprop="dateModified" datetime="2022-05-24T18:31:49+08:00">2022-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="ptmalloc的设计概述"><a href="#ptmalloc的设计概述" class="headerlink" title="ptmalloc的设计概述"></a>ptmalloc的设计概述</h1><h3 id="ptmalloc内存管理的设计假设"><a href="#ptmalloc内存管理的设计假设" class="headerlink" title="ptmalloc内存管理的设计假设"></a>ptmalloc内存管理的设计假设</h3><p>ptmalloc的设计假设是对于ptmalloc的基本行为概述，可以从宏观层面掌握ptmalloc在内存分配中采取的行为。  </p>
<ol>
<li>具有长周期的大内存分配使用mmap<a href="mmap%E5%92%8Cbrk%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%96%B9%E5%BC%8F%EF%BC%8Cmmap%E6%98%AF%E9%80%9A%E8%BF%87mmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9B%B4%E6%8E%A5%E7%94%B3%E8%AF%B7%E4%B8%80%E5%9D%97%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%80%8Cbrk%E6%98%AF%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%94%B9%E5%8F%98%E5%86%85%E6%A0%B8%E4%B8%ADmm_struct(%E6%8F%8F%E8%BF%B0%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%93%E6%9E%84)%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84brk%E5%80%BC%EF%BC%8C%E6%9D%A5%E6%9B%B4%E6%94%B9heap%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BB%8E%E8%80%8C%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A4%9A%E7%A9%BA%E9%97%B4%E3%80%82%EF%BC%88%E6%AD%A4%E5%A4%96mmap%E5%9C%A8ptmalloc%E4%B8%AD%E6%80%BB%E6%98%AF%E6%98%A0%E5%B0%84%E5%8C%BF%E5%90%8D%E6%95%B0%E6%8D%AE%E6%AE%B5%EF%BC%89">^1</a>。</li>
<li>特别大的内存分配总是使用mmap。</li>
<li>具有短周期的内存分配使用brk。</li>
<li>尽量只缓存临时使用的空闲小内存块，对大内存或者长周期的大内存在释放时都直接还给操作系统。</li>
<li>对空闲的小内存块只会在malloc和free的时候进行合并<a href="%E5%90%88%E5%B9%B6%E6%98%AF%E6%8C%87%E5%AF%B9%E7%89%A9%E7%90%86%E7%9B%B8%E9%82%BB%E7%9A%84chunk%E5%90%88%E5%B9%B6%EF%BC%8C%E5%B9%B6%E9%9D%9E%E6%8C%87%E5%AF%B9bins%E4%B8%AD%E7%9B%B8%E9%82%BB%E7%9A%84chunk%E5%90%88%E5%B9%B6">^1.1</a>,free时空闲内存块可能会放入pool中，不一定返还给操作系统。</li>
<li>收缩堆的条件是当前free的块的大小加上前后能合并的thunk大小大于64kb，并且堆顶的大小达到阈值，才会把堆最顶端的空闲内存返还给操作系统。</li>
<li>多个线程可以从同一个分配区（arena）中分配内存，ptmalloc假设A线程释放一块内存后，线程B会申请类似大小的内存，但是A释放的内存跟B需要的内存并不一定完全相等，可能会有一个小误差，就需要不断对内存块进行切割和合并，这个过程可能会产生内存碎片。</li>
</ol>
<h3 id="内存管理的数据结构"><a href="#内存管理的数据结构" class="headerlink" title="内存管理的数据结构"></a>内存管理的数据结构</h3><h4 id="Main-arena-与-non-main-arena"><a href="#Main-arena-与-non-main-arena" class="headerlink" title="Main_arena 与 non_main_arena"></a>Main_arena 与 non_main_arena</h4><p>每个进程都有一个主分配区和多个非主分配区<a href="%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E9%87%8F%E6%9C%89%E5%85%B3">^2</a>, 非主分配区的出现是为了减少多线程下对分配区的竞争。主分配区能使用mmap和sbrk进行内存管理，非主分配区只能使用mmap。分配区<a href="%E5%88%86%E9%85%8D%E5%8C%BA%E5%B9%B6%E9%9D%9E%E6%8C%87%E8%A6%81%E8%A2%AB%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%87%E8%83%BD%E5%A4%9F%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%89">^3</a>一旦增加就不会再减少。</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>用户请求分配的空间在 ptmalloc 中都使<br>用一个 chunk 来表示。用户调用 free()函数释放掉的内存也并不是立即就归还给操作系统，，它们也会被表示为一个 chunk，ptmalloc 使用特定的数据结构来管理这些空闲的 chunk。chunk的结构如下:<br><img src="/images/images/chunk.PNG" alt="alt chunk"><br>chunk的结构和特性在《glibc内存管理ptmalloc源代码分析》中写的十分详细，此处不再复述。本文主要是对于该文章中源代码分析部分过于简略且难以理解的部分作出补充。</p>
<h3 id="空闲chunk的容器"><a href="#空闲chunk的容器" class="headerlink" title="空闲chunk的容器"></a>空闲chunk的容器</h3><p>ptmalloc使用bins来管理空闲的chunk。（请参考原作部分）</p>
<h3 id="sbrk与mmap"><a href="#sbrk与mmap" class="headerlink" title="sbrk与mmap"></a>sbrk与mmap</h3><p>前文提到过，malloc分配内存时，对于主分配区而言，既能使用mmap来直接映射新内存，也能通过改变brk值来扩展heap。其不同分配方式的条件如下：</p>
<ol>
<li>ptmalloc在开始时，若请求的空间小于 mmap分配阈值（mmap threshold，默认值为 128KB）时，主分配区会调用 sbrk()增加一块大小为 (128 KB + chunk_size) align 4KB 的空间作为 heap。非主分配区会调用 mmap 映射一块大小为HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。</li>
<li>当用户请求内存分配时，首先会在这个空间内找一块合适的 chunk 给用户。当用户释放了 heap 中的 chunk 时，ptmalloc 又会使用 fastbins 和 bins 来组织空闲 chunk。以备用户的下一次分配。</li>
<li>若需要分配的 chunk 大小小于 mmap分配阈值，而 heap 空间又不够，则此时主分配区会通过 sbrk()调用来增加 heap 大小，非主分配区会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到 4KB。</li>
<li>当用户的请求超过 mmap 分配阈值，ptmalloc 会尝试使用 mmap()直接映射一块内存到进程内存空间。使用 mmap()直接映射的 chunk 在释放时直接解除映射，而不再属于进程的内存空间。任何对该内存的访问都会产生段错误。而在heap 中或是 sub-heap 中分配的空间则可能会留在进程内存空间内，还可以再次引用（当然是很危险的）。</li>
<li>当 ptmalloc munmap chunk 时，如果回收的 chunk 空间大小大于 mmap 分配阈值的当前值，并且小于DEFAULT_MMAP_THRESHOLD_MAX（32 位系统默认为 512KB，64 位系统默认为 32MB），ptmalloc 会把 mmap 分配阈值调整为当前回收的 chunk 的大小，并将 mmap 收缩阈值（mmap trim threshold）设置为 mmap 分配阈值的 2 倍。这就是 ptmalloc 的对 mmap分配阈值的动态调整机制，该机制是默认开启的，当然也可以用 mallopt()关闭该机制。</li>
</ol>
<h1 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h1><h3 id="用如下的图来描述malloc的流程："><a href="#用如下的图来描述malloc的流程：" class="headerlink" title="用如下的图来描述malloc的流程："></a>用如下的图来描述malloc的流程：</h3><p><img src="/images/images/malloc.png" alt="alt malloc"></p>
<h3 id="用如下图来描述free的流程："><a href="#用如下图来描述free的流程：" class="headerlink" title="用如下图来描述free的流程："></a>用如下图来描述free的流程：</h3><p><img src="/images/images/free.png" alt="alt free"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ptmalloc同样具有函数mallopt()来配置选项，此处不再细写。</p>
<h1 id="ptmalloc的源代码分析-gt-lt"><a href="#ptmalloc的源代码分析-gt-lt" class="headerlink" title="ptmalloc的源代码分析(&gt;_&lt;)"></a>ptmalloc的源代码分析(&gt;_&lt;)</h1><p>此段用于对《glibc内存管理ptmalloc源代码分析》中的源码部分进行更加详细的注释（原作的代码部分注释过于简略，对很多凭空出现的变量没有指明其作用）。</p>
<h3 id="chunk及其相关宏和数据结构的声明"><a href="#chunk及其相关宏和数据结构的声明" class="headerlink" title="chunk及其相关宏和数据结构的声明"></a>chunk及其相关宏和数据结构的声明</h3><ol>
<li>chunk的声明<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"> INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). </span></span><br><span class="line"><span class="comment">                            前一个chunk的大小（如果前一个chunk是空闲的，否则无意义）*/</span></span><br><span class="line"> INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. </span></span><br><span class="line"><span class="comment">                        大小占多少byte，包括了开销（即除了用户能使用的空间之外用于表示chunk信息的额外空间，chunk具有空间复用，根据chunk是否空闲来具体分析其overhead）*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. </span></span><br><span class="line"><span class="comment">                          双向链表指针，只有chunk空闲的时候有用*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"> <span class="comment">/* Only used for large blocks: pointer to next larger size. </span></span><br><span class="line"><span class="comment"> 只用于large bin中的大块chunk，指向下一个更大的chunk*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. </span></span><br><span class="line"><span class="comment">                                    用于双向链表，只在chunk空闲时有用*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
2.相关转换和检查的宏<br>声明：指向chunk的指针指的是指向chunk头的指针，而指向mem的指针指的是指向用户存储数据的空间的指针（请结合上面那幅chunk的图查看）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back </span></span><br><span class="line"><span class="comment">chunk头指针到用户使用空间指针的来回转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((Void_t*)((char*)(p) + 2*SIZE_SZ)) <span class="comment">/* p代表指向chunk头的指针，这个宏将其转换为用户能使用的空间的指针（就是让p跳过sizeofprev和size）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))<span class="comment">/*mem代表指向用户空间的指针，这个宏将其转换为chunk头的指针*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk </span></span><br><span class="line"><span class="comment">最小的可能chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))<span class="comment">/*offsetof(a, b),求b在a中的偏移，这里fd_nextsize的偏移正好是最小chunk的大小*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk </span></span><br><span class="line"><span class="comment">我们可以分配的最小chunk是一个对齐的极小chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE \</span></span><br><span class="line"><span class="meta"> (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))<span class="comment">/*对min_chunk_size进行了2*SIZE_SZ对齐，不必过于关心*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment </span></span><br><span class="line"><span class="comment">检查m是否对齐*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta"> ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta"> &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"> <span class="comment">/*这里是强制让chunk指针p对齐*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>这几个宏用于将用户请求的分配大小转换成内部需要分配的 chunk 大小，这里需要注意的在转换时不但考虑的地址对齐，还额外加上了 SIZE_SZ，这意味着 ptmalloc 分配内存需要一个额外的overhead，为SIZE_SZ字节，通过chunk的空间复用，我们很容易得出这个overhead为 SIZE_SZ。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment"> padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment"> low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> 检查请求值是否过大以至于在填充和对齐时会发生溢出（原文是零环绕，我觉得溢出更好理解，可能有错&gt;_&lt;）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req) \</span></span><br><span class="line"><span class="meta"> ((unsigned long)(req) &gt;= \</span></span><br><span class="line"><span class="meta"> (unsigned long)(INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version </span></span><br><span class="line"><span class="comment">将请求的内存值转换为应当分配的chunk大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req) \</span></span><br><span class="line"><span class="meta">31</span></span><br><span class="line"> (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \</span><br><span class="line"> MINSIZE : \</span><br><span class="line"> ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same, except also perform argument check </span></span><br><span class="line"><span class="comment">这个宏实际上是将上面两个结合起来，先判断是否超过范围，在根据判断返回应当分配的chunk大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta"> <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123; \</span></span><br><span class="line"><span class="meta"> MALLOC_FAILURE_ACTION; \</span></span><br><span class="line"><span class="meta"> return 0; \</span></span><br><span class="line"><span class="meta"> &#125; \</span></span><br><span class="line"><span class="meta"> (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>chunk 在分割时总是以地址对齐（默认是 8 字节，可以自由设置，但是 8 字节是最小值并且设置的值必须是 2 为底的幂函数值，即是 alignment &#x3D; 2^n，n 为整数且 n&gt;&#x3D;3）的方式来进行的，所以用 chunk-&gt;size 来存储本 chunk 块大小字节数的话，其末 3bit 位总是 0，因此这三位可以用来存储其它信息,以下是对这三位的设置宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use </span></span><br><span class="line"><span class="comment">前一个chunk为使用中，则P位设为1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk </span></span><br><span class="line"><span class="comment">抽取前一个chunk的inuse位（即当前chunk的P位）（p是chunk头指针）（前一个chunk是否空闲是由它下一个chunk的P位决定的）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() </span></span><br><span class="line"><span class="comment">该chunk由mmap分配而来，则M位设为1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk </span></span><br><span class="line"><span class="comment">检查chunk是否由mmap分配*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment"> from a non-main arena. This is only set immediately before handing</span></span><br><span class="line"><span class="comment"> the chunk to the user, if necessary. </span></span><br><span class="line"><span class="comment"> 该chunk属于非主分配区，则A位设为1，如果必要的话，只在将chunk交给用户之前即刻设置*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena </span></span><br><span class="line"><span class="comment">检查chunk是否来自非主分配区*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以下是有关定位chunk的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义SIZE_BITS，用于去掉后三位的影响，返回chunk实际大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits </span></span><br><span class="line"><span class="comment">得到chunk大小，忽略控制信息*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. </span></span><br><span class="line"><span class="comment">返回p指向的chunk物理地址上下一个chunk的指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk </span></span><br><span class="line"><span class="comment">返回p指向的chunk物理地址上上一个chunk的指针（只有在前一个chunk空闲时这个宏才有意义（看代码实现就知道了哦））*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk </span></span><br><span class="line"><span class="comment">返回p+s，将p+s处的空间当作一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用于设置&#x2F;检查&#x2F;清除chunk使用标志位的宏<br>注意：当前chunk的使用标志位储存在下一个chunk里面（P位）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit </span></span><br><span class="line"><span class="comment">抽取p指向chunk的inuse位（当前chunk的inuse位是下一个chunk的P位）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)\</span></span><br><span class="line"><span class="meta">((((mchunkptr)(((char*)(p))+((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing </span></span><br><span class="line"><span class="comment">设置或清除p所指向chunk的inuse位*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>7.设置，检查，清除指定chunk中的inuse位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places </span></span><br><span class="line"><span class="comment">设置，检查，清除指定chunk中的inuse位*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span></span><br><span class="line"><span class="comment">/*就是把p+s指向的空间当作一个chunk，然后把设置P位（感觉有点怪，明明设置的是P位，却叫inuse位设置宏）*/</span></span><br></pre></td></tr></table></figure>
<p>8.设置chunk的size的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit </span></span><br><span class="line"><span class="comment">直接设置chunk（由p指向）的szie域为s，并保留原来的控制信息*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s) ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field </span></span><br><span class="line"><span class="comment">直接设置chunk的size域为s*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) </span></span><br><span class="line"><span class="comment">将foot的值设置为s*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s) (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：前面有所提到，foot就是下一个chunk保存其物理相邻的上一个空闲chunk大小的位置，由于s正是要设置的chunk大小，所以set_foot宏用p+s定位到下一个chunk的prev_size域。</p>
<h3 id="bins及其相关源码解析"><a href="#bins及其相关源码解析" class="headerlink" title="bins及其相关源码解析"></a>bins及其相关源码解析</h3><h4 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h4><p>Small bins在bins的数组（其实不准确，以下会有说明）中从下标2开始，一直到下标65，一共有64个，但一般实际用到的只有62个（最后两个不用）。每个Small bin是一个链表头，包括malloc_chunk* fd 和 malloc_chunk* bk两个指针。注意，由于源码中拥有上述两个指针的是malloc_chunk结构体，在编写代码的时候，一个指向malloc_chunk结构体的指针可以直接引用其中的元素，但如果每个bin都定义为一个malloc_chunk,其mem，size，prev_size空间都没有用，实际上就浪费了，因此直接定义一个256大小的指针数组（bin有128个），每个元素是malloc_chunk* 指针，用两个元素代表一个bin（fd和bk），但是又用一个malloc_chunk指针p指向bin向前偏移2个SIZE_SZ的位置（或者说指向该bin的上一个bin），这样就可以用p-&gt;fd和p-&gt;bk来直接引用这两个指针，更为方便和易读，如下图<br><img src="/images/images/bins.png" alt="alt bins"></p>
</li>
</ol>
<p>注意：以下的下标（index）都是表示bin的下标而非数组元素的下标<br>ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index有如下关系：</p>
<p>Chunk_size&#x3D;2 * SIZE_SZ * index（SIZE_SZ可看作当前系统指针的大小，反正数值一样）</p>
<p>ptmalloc 维护了 62 个双向环形链表（每个链表都具有链表头节点，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲 chunk 的大小一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可以用如下图来表示在 SIZE_SZ 为 4B 的平台上 ptmalloc 对 512B 字节以下的空闲 chunk 组织方式（所谓的分箱机制）<br><img src="/images/images/small_bins.png" alt="alt small_bins"></p>
<h4 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h4><p>在 SIZE_SZ 为 4B 的平台上，大于等于 512B 的空闲 chunk，或者，在 SIZE_SZ 为 8B 的平台上，大小大于等于 1024B 的空闲 chunk，由 sorted bins 管理。Large bins 一共包括 63 个 bin，每个 bin 中的 chunk 大小不是一个固定公差的等差数列，而是分成 6 组 bin，每组 bin 是一个固定公差的等差数列，每组的 bin 数量依次为 32、16、8、4、2、1，公差依次为 64B、512B、4096B、32768B、262144B 等.<br>以 SIZE_SZ 为 4B 的平台为例，第一个 large bin 的起始 chunk 大小为 512B，共 32 个 bin，公差为 64B，等差数列满足如下关系：Chunk_size&#x3D;512 + 64 * index<br>第二个 large bin 的起始 chunk 大小为第一组 bin 的结束 chunk 大小，满足如下关系：<br>Chunk_size&#x3D;512 + 64 * 32 + 512 * index<br>同理，我们可计算出每个 bin 的起始 chunk 大小和结束 chunk 大小。这些 bin 都是很有规律的，其实 small bins 也是满足类似规律，small bins 可以看着是公差为 8 的等差数列，一共有 64 个 bin（第 0 和 1bin 不存在），所以我们可以将 small bins 和 large bins 存放在同一个包含 128 个 chunk 的数组上，数组的前一部分位 small bins，后一部分为 large bins，每个 bin的 index 为 chunk 数组的下标，于是，我们可以根据数组下标计算出该 bin 的 chunk 大小（smallbins）或是 chunk 大小范围（large bins），也可以根据需要分配内存块大小计算出所需 chunk所属 bin 的 index，ptmalloc 使用了一组宏巧妙的实现了这种计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128  <span class="comment">/*定义了bin的数量*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64 <span class="comment">/*定义了small_bin的数量*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT <span class="comment">/*malloc_alignment 定义为 2*SIZE_SZ,是用来处理chunk地址对齐的宏*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE (NSMALLBINS * SMALLBIN_WIDTH) <span class="comment">/*定义最小的Large chunk大小*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta"> ((unsigned long)(sz) <span class="string">&lt; (unsigned long)MIN_LARGE_SIZE) /*这个宏用于判断sz（p-&gt;</span>size）的大小是否属于small chunk的范围*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta"> (SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) &gt;&gt; 4) : (((unsigned)(sz)) &gt;&gt; 3))<span class="comment">/*通过chunk的大小返回其在small bins中的index（从2开始）*/</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*以下分别是32位和64位下根据size大小返回其在Large bins 中index（从66开始）的宏*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 38)? 56 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20)? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta"> 126)</span></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48)? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">36</span></span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)? <span class="number">91</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)? <span class="number">110</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)? <span class="number">119</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)? <span class="number">124</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>): \</span><br><span class="line"> <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta"> (SIZE_SZ == 8 ? largebin_index_64 (sz) : largebin_index_32 (sz))<span class="comment">/*这个宏是把上面的两个结合起来，直接通过size返回在large bins中的index（无关操作系统位数）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))<span class="comment">/*这个是上面宏的最后缝合体，直接通过size返回bins中的index*/</span></span></span><br></pre></td></tr></table></figure>

<h4 id="几个对bins的操作宏"><a href="#几个对bins的操作宏" class="headerlink" title="几个对bins的操作宏"></a>几个对bins的操作宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mbinptr</span>;</span><span class="comment">/*后面的源代码常用这里的定义，建议记住</span></span><br><span class="line"><span class="comment">是malloc_bin_pointer的简写，前面讲过了bin的访问方式*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist </span></span><br><span class="line"><span class="comment">通过index返回bin的地址，注意，bin_at(0)不存在*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \<span class="comment">/*m是malloc_state结构体指针，后面会讲，这里面放着bins数组，i就是传入的index*/</span></span></span><br><span class="line"> (mbinptr) (((<span class="type">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>])) \</span><br><span class="line"> - offsetof (<span class="keyword">struct</span> malloc_chunk, fd))<span class="comment">/*这个offsetof前面也有讲过，这段代码仔细看看就理解了*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回b指向bin的下一个bin的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char*)(b) + (sizeof(mchunkptr)&lt;&lt;1)))<span class="comment">/*sizeof（mchunkptr）&lt;&lt;1其实就是8&lt;&lt;1 == 16,正好是两个bin之间的距离*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins </span></span><br><span class="line"><span class="comment">bin中的第一个chunk和最后一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)<span class="comment">/*bin维护的是双向链表哦*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list </span></span><br><span class="line"><span class="comment">将一个chunk从bin维护的双向链表中摘下*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; \<span class="comment">/*这里传BK和FD就是为了让你传个载体，毕竟宏里面不好定义新变量*/</span></span></span><br><span class="line"> FD = P-&gt;fd; \</span><br><span class="line"> BK = P-&gt;bk; \</span><br><span class="line"> <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) \<span class="comment">/*这个宏直接返回第一个参数（迷），这里就是判断传入的p所指向的chunk是否真的在双向链表中*/</span></span><br><span class="line"> malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); \<span class="comment">/*打印错误信息*/</span></span><br><span class="line"> <span class="keyword">else</span> &#123; \</span><br><span class="line"> FD-&gt;bk = BK; \</span><br><span class="line"> BK-&gt;fd = FD; \<span class="comment">/*将chunk取出*/</span></span><br><span class="line"> <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) \</span><br><span class="line"> &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123; \<span class="comment">/*若P所指向的chunk不在small bin中且该chunk有fd_nextsize指针（说明是large chunk）*/</span></span><br><span class="line"> <span class="comment">/*以下是当为large chunk时，还需要做的操作（从横向循环链表中删除）*/</span></span><br><span class="line"> assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); \</span><br><span class="line"> assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); \</span><br><span class="line"> <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123; \</span><br><span class="line"> <span class="keyword">if</span> (P-&gt;fd_nextsize == P) \</span><br><span class="line"> FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \</span><br><span class="line"> <span class="keyword">else</span> &#123; \</span><br><span class="line"> FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span><br><span class="line"> FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span><br><span class="line"> P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \</span><br><span class="line"> P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line"> P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span><br><span class="line"> P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h4><p>Unsorted bin 可以看作是 small bins 和 large bins 的 cache，只有一个 unsorted bin，以双向链表管理空闲 chunk，空闲 chunk 不排序，所有的 chunk 在回收时都要先放到 unsorted bin中，分配时，如果在 unsorted bin 中没有合适的 chunk，就会把 unsorted bin 中的所有 chunk分别加入到所属的 bin 中，然后再在 bin 中分配合适的 chunk。Bins 数组中的元素 bin[1]（bins数组下标是1到128哦）用于存储 unsorted bin 的 chunk 链表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1)) <span class="comment">/*用于获得unsorted bin的地址，M是malloc_state结构体指针*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))<span class="comment">/*初始化top chunk的宏，这里暂时把top chunk当作unsorted chunk来初始化，写的很迷惑，不知道干什么的*/</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h4><p>Fast bins 主要是用于提高小内存的分配效率，默认情况下，对于 SIZE_SZ 为 4B 的平台，小于 64B 的 chunk 分配请求，对于 SIZE_SZ 为 8B 的平台，小于 128B 的 chunk 分配请求，首先会查找 fast bins 中是否有所需大小的 chunk 存在（精确匹配），如果存在，就直接返回。<br>Fast bins 可以看着是 LIFO 的栈，使用单向链表实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mfastbinptr</span>;</span><span class="comment">/*指向fast bin的指针也和其他指向bin的指针一样定义为malloc chunk指针，便于访问fd和bk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])<span class="comment">/*ar_ptr是指向malloc_state结构体的指针，fastbinsY是储存fast bin的数组，也定义在malloc_state中，与bins数组分开定义</span></span></span><br><span class="line"><span class="comment"><span class="meta">这个宏的作用是通过idex返回fast bin的地址*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta"> ((((unsigned int)(sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"> <span class="comment">/*这个宏是根据chunk size大小返回其对应的fast bin index*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support </span></span><br><span class="line"><span class="comment">fast bin所支持的最大请求值大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE))+1)<span class="comment">/*这里先将请求值转换为实际chunk大小值，再通过chunk大小转换为index，index加1即为bin的数量（10个）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br><span class="line"><span class="comment">/*FASTBIN_CONSOLIDATION_THRESHOLD 为 64k，当每次释放的 chunk 与该chunk 相邻的空闲 chunk 合并后的大小大于 64k </span></span><br><span class="line"><span class="comment">时，就认为内存碎片可能比较多了，就需要把 fast bins 中的所有 chunk 都进行合并，以减少内存碎片对系统的影响。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*定义了默认的fast bin中最大chunk大小，因此fast bins通常只使用了前7个（0~6）*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta"> global_max_fast = (((s) == 0) \</span></span><br><span class="line"><span class="meta"> ? SMALLBIN_WIDTH: ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"> <span class="comment">/*SMALLBIN_WIDTH定义为MALLOC_ALIGN_MASK == 2*SIZE_SZ</span></span><br><span class="line"><span class="comment"> ptmalloc默认情况下调用 set_max_fast(s)将全局变量 global_max_fast 设置为 DEFAULT_MXFAST*/</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"> <span class="comment">/*get_max_fast()用于获得这个全局变量 global_max_fast的值。*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="核心结构体分析"><a href="#核心结构体分析" class="headerlink" title="核心结构体分析"></a>核心结构体分析</h3><p>每个分配区是 struct malloc_state 的一个实例，ptmalloc 使用 malloc_state 来管理分配区，而参数管理使用 struct malloc_par，全局拥有一个唯一的 malloc_par 实例。</p>
<h4 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h4><p>1.malloc_state定义<br>malloc_state 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line"> <span class="comment">/* Serialize access. </span></span><br><span class="line"><span class="comment"> 用于串行访问的锁*/</span></span><br><span class="line"> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Flags (formerly in max_fast). </span></span><br><span class="line"><span class="comment"> 标志位*/</span></span><br><span class="line"> <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line"> <span class="comment">/* Statistics for locking. Only used if THREAD_STATS is defined. </span></span><br><span class="line"><span class="comment"> 用于对锁的统计变量，仅在THREAD_STATS定义时使用，默认没有定义 THREAD_STATS，所以不会对锁的争用情况做统计。*/</span></span><br><span class="line"> <span class="type">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Fastbins </span></span><br><span class="line"><span class="comment"> fastbinsY 拥有 10（NFASTBINS）个元素的数组，用于存放每个 fast chunk 链表头指针，所以 fast bins 最多包含 10 个 fast chunk 的单向链表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin </span></span><br><span class="line"><span class="comment"> top chunk的基址*/</span></span><br><span class="line"> mchunkptr top;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* The remainder from the most recent split of a small request </span></span><br><span class="line"><span class="comment"> 定义了last remainder的指针</span></span><br><span class="line"><span class="comment"> 分配区上次分配 small chunk 时，从一个 chunk 中分裂出一个 small chunk 返回给用户，分裂后的剩余部分形成一个 chunk，last_remainder 就是指向的这个 chunk。*/</span></span><br><span class="line"> mchunkptr last_remainder;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Normal bins packed as described above </span></span><br><span class="line"><span class="comment"> 普通的bin数组（除了fast bins以外的bin都在这里面）*/</span></span><br><span class="line"> mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Bitmap of bins </span></span><br><span class="line"><span class="comment"> bins的bitmap，下面会详细解释的*/</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Linked list </span></span><br><span class="line"><span class="comment"> 由于每个分配区都有一个malloc_state结构体，用以下的指针将它们连起来*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD<span class="comment">/*这个宏查不到，后面版本的libc不再有PER_THREAD的判断，直接定义了以下变量*/</span></span></span><br><span class="line"> <span class="comment">/* Linked list for free arenas. </span></span><br><span class="line"><span class="comment"> 这个是多线程时，用于连接空闲分配区的指针*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Memory allocated from the system in this arena. </span></span><br><span class="line"><span class="comment"> 这个分配区管理的从系统获得的内存空间*/</span></span><br><span class="line"> INTERNAL_SIZE_T system_mem;</span><br><span class="line"> INTERNAL_SIZE_T max_system_mem;</span><br><span class="line"><span class="comment">/*前面定义过 #define INTERNAL_SIZE_T size_t，size_t是系统指针长度</span></span><br><span class="line"><span class="comment">system_mem是当前分配区已经分配的内存大小，max_system_mem是当前分配区最大能分配的内存大小*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>THREAD_STATS应该是在多分配区时定义的宏（翻宏定义发现其在arena.c中首次定义）</p>
<p>2.用于设置flag中fast chunk的标志位bit0的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U) <span class="comment">/*首先将FASTCHUNKS_BIT定义为1，用于作掩码（大概）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="comment">/*检查是否有fast chunks，M是指向malloc_state结构体的指针，其中flag的bit0位为1，则没有fast chunk，为0，则有*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS<span class="comment">/*当这个宏定义的时候，将clear_fastchunks 和 set_fastchunks 定义为下*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将flag的bit0位置1，表示不再有fast chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="comment">/*catomic是原子操作，后面跟的是操作方式，如catomic_or(a,b) 表示 a = a | b</span></span><br><span class="line"><span class="comment">注意，这里的M又表示malloc_state结构体，而非其指针（写的真的迷）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将flag的bit0位置0，表示有fast chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">/*当ATOMIC_FASTBINS宏没有定义的时候，将clear_fastchunks 和 set_fastchunks 定义为下*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里就直接用逻辑操作来更改flag的bit0了*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) ((M)-&gt;flags |= FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) ((M)-&gt;flags &amp;= ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*暂时不必关心这样分开定义的原因（我也不知道），只需要知道这两个宏的作用即可*/</span></span><br></pre></td></tr></table></figure>
<p>注意：刚初始化完成后的 malloc_state 实例中，flags值为 0，表示该分配区中有 fast chunk，但实际上没有，试图从 fast bins 中分配 chunk 都会返回 NULL，在第一次调用函数 malloc_consolidate()对 fast bins 进行 chunk 合并时，如果 max_fast大于 0，会调用 clear_fastchunks 宏，标志该分配区中已经没有 fast chunk，因为函数malloc_consolidate()会合并所有的 fast bins 中的 chunk。clear_fastchunks 宏只会在函数malloc_consolidate()中调用。当有 fast chunk 加入 fast bins 时，就是调用 set_fastchunks 宏标识分配区的 fast bins 中存在 fast chunk。</p>
<p>3.用于设置flag中的bit1，是MORCORE的标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)<span class="comment">/*将NONCONTIGUOUS_BIT定义为2，也是当掩码*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断bit1是否为0，若为0，表示MORCORE返回连续的虚拟地址空间，为1则不连续*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断bit1是否为1（!=0）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面两个宏也是对bit1 的设置宏*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br></pre></td></tr></table></figure>
<p>对于主分配区，MORECORE 其实为 sbr()，默认返回连续虚拟地址空间，对于非主分配区，使用 mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为，而默认情况下 mmap 映射区域是不保证虚拟地址空间连续的，所以非住分配区默认分配非连续虚拟地址空间。</p>
<p>4.binmap概述及其相关宏<br>binmap 字段是一个 int 数组，ptmalloc 用一个 bit 来标识该 bit 对应的 bin 中是否包含空闲 chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这两个宏一起定义了BITSPERMAP，用于BINMAPSIZE宏的定义，</span></span><br><span class="line"><span class="comment">但我不知道为什么要分开定义，或许是为了扩展性*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*binmap数组的大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP) <span class="comment">/*看来就是NBINS / 32（因为每个block可以储存32个bit）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将bin的index转换为binmap中的block（块）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)<span class="comment">/*binmap数组中每个binmap代表一个块，每个bit位代表一个bin，</span></span></span><br><span class="line"><span class="comment"><span class="meta">bin的index从整个数组的低位到高位依次对应</span></span></span><br><span class="line"><span class="comment"><span class="meta">通过block和bit组合来确定一个bin，</span></span></span><br><span class="line"><span class="comment"><span class="meta">如bin[1]对应block[0]的bit1位</span></span></span><br><span class="line"><span class="comment"><span class="meta">bin[80]对应block[2]的bit16位*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将bin的index转换为binmap中的bit位*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT)-1))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面的宏分别是标记binmap对应bit为1，标记为0，检查binmap对应bit的值</span></span><br><span class="line"><span class="comment">便于快速得知对应bin中是否有chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m,i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span></span><br></pre></td></tr></table></figure>
<h4 id="Malloc-par"><a href="#Malloc-par" class="headerlink" title="Malloc_par"></a>Malloc_par</h4><p>1.Malloc_par 的定义<br>Malloc_par是全局唯一的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> &#123;</span></span><br><span class="line"> <span class="comment">/* Tunable parameters */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;<span class="comment">/*收缩阈值，默认为128KB，可通过；mallopt()函数设置*/</span></span><br><span class="line"> INTERNAL_SIZE_T top_pad;<span class="comment">/*top_pad是在内存分配时额外分配的内存*/</span></span><br><span class="line"> INTERNAL_SIZE_T mmap_threshold;<span class="comment">/*mmap分配阈值，默认为128KB（会自己动态修改，查看前文的描述）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD <span class="comment">/*后面版本的libc不再有PER_THREAD的判断，直接定义了以下变量，用于限制分配区的数量*/</span></span></span><br><span class="line"> INTERNAL_SIZE_T arena_test;</span><br><span class="line"> INTERNAL_SIZE_T arena_max;</span><br><span class="line"><span class="comment">/*在 32 位系统上 arena_test 默认值为 2，64 位系统上的默认值为 8，当每个进程的分配区数量小于等于 arena_test 时，</span></span><br><span class="line"><span class="comment">不会重用已有的分配区。为了限制分配区的总数，用 arena_max 来保存分配区的最大数量，当系统中的分配区数量达到 arena_max，</span></span><br><span class="line"><span class="comment">就不会再创建新的分配区，只会重用已有的分配区。这两个字段都可以使用 mallopt()函数设置。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="comment">/* Memory map support */</span></span><br><span class="line"> <span class="type">int</span> n_mmaps;<span class="comment">/*当前进程使用mmap分配的内存块个数*/</span></span><br><span class="line"> <span class="type">int</span> n_mmaps_max;<span class="comment">/*mmap可分配的内存块最大数量（默认为65536，可用mallopt函数修改）*/</span></span><br><span class="line"> <span class="type">int</span> max_n_mmaps;<span class="comment">/*当前进程使用 mmap()函数分配的内存块的数量的最大值，有关系 n_mmaps &lt;= max_n_mmaps 成立。这个字段</span></span><br><span class="line"><span class="comment"> 是由于 mstats()函数输出统计需要这个字段。（迷）*/</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment"> it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment"> dynamic behavior. </span></span><br><span class="line"><span class="comment"> 表示是否开启mmap分配阈值动态调整，默认为0，表示开启*/</span></span><br><span class="line"> <span class="type">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Cache malloc_getpagesize </span></span><br><span class="line"><span class="comment"> 表示系统页的大小，默认为4KB*/</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> pagesize;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Statistics */</span></span><br><span class="line"> <span class="comment">/*mmapped_mem 和 max_mmapped_mem 都用于统计 mmap 分配的内存大小，一般情况下两个字段的值相等，max_mmapped_mem 用于 mstats()函数。*/</span></span><br><span class="line"> INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line"> INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line"></span><br><span class="line"> INTERNAL_SIZE_T max_total_mem; <span class="comment">/* only kept for NO_THREADS 在单线程情况下用于统计进程分配的内存总数。*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* First address handed out by MORECORE/sbrk. </span></span><br><span class="line"><span class="comment"> 堆的起始地址*/</span></span><br><span class="line"> <span class="type">char</span>* sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配区的初始化"><a href="#分配区的初始化" class="headerlink" title="分配区的初始化"></a>分配区的初始化</h3><ol>
<li><p>相关全局变量<br>Ptmalloc 定义了如下几个全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span>;</span><span class="comment">/*主分配区只有这一个，但非主分配区在需要时可以继续定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is only one instance of the malloc parameters. </span></span><br><span class="line"><span class="comment">mp_是全局唯一一个malloc_par 实例，用于管理参数和统计信息*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum size of memory handled in fastbins. </span></span><br><span class="line"><span class="comment">fast bins 中最大的chunk大小*/</span></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主分配区main_arena初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(av)</span> mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*写的很迷，但大体就是定义一个初始化函数，形参为malloc_state* av*/</span></span></span><br><span class="line"><span class="comment">/*分析下列函数可知av是malloc_state指针，可原文写的是av是malloc_state实例,emmmm*/</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> mbinptr bin;</span><br><span class="line"> <span class="comment">/* Establish circular links for normal bins </span></span><br><span class="line"><span class="comment"> 先初始化bins，由于bin都为空，所以将各自的fd和bk都指向自己*/</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line"> bin = bin_at(av,i);</span><br><span class="line"> bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line"> <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*写的什么鬼，没看懂*/</span></span></span><br><span class="line"></span><br><span class="line"> set_noncontiguous(av);</span><br><span class="line"> <span class="keyword">if</span> (av == &amp;main_arena)<span class="comment">/*如果是主分配区，设置fast chunk最大值global_max_fast*/</span></span><br><span class="line"> set_max_fast(DEFAULT_MXFAST);</span><br><span class="line"></span><br><span class="line"> av-&gt;flags |= FASTCHUNKS_BIT;<span class="comment">/*设置flag的bit0*/</span></span><br><span class="line"> av-&gt;top = initial_top(av);<span class="comment">/*初始化top chunk，此时的top chunk指针指向</span></span><br><span class="line"><span class="comment"> unsorted chunk（看前面的initial_top定义）*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>ptmalloc参数初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set up basic state so that _int_malloc et al can work. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init_minimal</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEFAULT_TOP_PAD != 0</span></span><br><span class="line"> mp_.top_pad = DEFAULT_TOP_PAD;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> mp_.n_mmaps_max = DEFAULT_MMAP_MAX;</span><br><span class="line"> mp_.mmap_threshold = DEFAULT_MMAP_THRESHOLD;</span><br><span class="line"> mp_.trim_threshold = DEFAULT_TRIM_THRESHOLD;</span><br><span class="line"> mp_.pagesize = malloc_getpagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line"> mp_.arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>);</span><br><span class="line"> narenas = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是将全局变量 mp_的字段初始化为默认值,会根据系统 cpu 的个数设置 arena_test 的值，默认 32 位系统是双核，64 位系统为 8 核，arena_test 也就设置为相应的值。</p>
</li>
<li><p>配置选项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mALLOPt</span><span class="params">(<span class="type">int</span> param_number, <span class="type">int</span> value)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mALLOPt</span><span class="params">(param_number, value)</span> <span class="type">int</span> param_number; <span class="type">int</span> value;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line"> mstate av = &amp;main_arena;</span><br><span class="line"> <span class="type">int</span> res = <span class="number">1</span>;<span class="comment">/*定义返回值为1，若配置失败，res会变成0*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*检查主分配区是否初始化，没有则调用ptmalloc_init初始化ptmalloc</span></span><br><span class="line"><span class="comment"> （注意，这里并没有直接初始化主分配区哦）*/</span></span><br><span class="line"> <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">0</span>)</span><br><span class="line"> ptmalloc_init ();</span><br><span class="line"></span><br><span class="line"> (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);<span class="comment">/*获取主分配区的锁*/</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Ensure initialization/consolidation </span></span><br><span class="line"><span class="comment"> 确保初始化，调用malloc_consolidate()函数，malloc_consolidate()函数会判断主分配</span></span><br><span class="line"><span class="comment"> 区是否已经初始化，如果没有，则初始化主分配区。*/</span></span><br><span class="line"> malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下是配置选项*/</span></span><br><span class="line"> <span class="keyword">switch</span>(param_number) &#123;</span><br><span class="line"> <span class="keyword">case</span> M_MXFAST:<span class="comment">/*修改MAX_FAST_SIZE值为value*/</span></span><br><span class="line"> <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123;</span><br><span class="line"> set_max_fast(value);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> res = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_TRIM_THRESHOLD:<span class="comment">/*修改trim_threshold（收缩阈值）值为value,</span></span><br><span class="line"><span class="comment"> no_dyn_threshold为1（关闭动态阈值调整）*/</span></span><br><span class="line"> mp_.trim_threshold = value;</span><br><span class="line"> mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_TOP_PAD:<span class="comment">/*将top_pad设为value,no_dyn_threshold为1（关闭动态阈值调整）*/</span></span><br><span class="line"> mp_.top_pad = value;</span><br><span class="line"> mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_MMAP_THRESHOLD:<span class="comment">/*设置mmap分配阈值*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_ARENAS</span></span><br><span class="line"> <span class="comment">/* Forbid setting the threshold too high. </span></span><br><span class="line"><span class="comment"> 禁止将mmap_threshold设置的过高*/</span></span><br><span class="line"> <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)value &gt; HEAP_MAX_SIZE/<span class="number">2</span>)</span><br><span class="line"> res = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> mp_.mmap_threshold = value;</span><br><span class="line"> mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_MMAP_MAX:<span class="comment">/*改变当前mmap分配内存块个数为value*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_MMAP</span></span><br><span class="line"> <span class="keyword">if</span> (value != <span class="number">0</span>)</span><br><span class="line"> res = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> mp_.n_mmaps_max = value;</span><br><span class="line"> mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_CHECK_ACTION:<span class="comment">/*设置检查行为*/</span></span><br><span class="line"> check_action = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_PERTURB:<span class="comment">/*不知道*/</span></span><br><span class="line"> perturb_byte = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="comment">/*定义了PER_THREAD时，可以设置这两个限制非主分配区的变量*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"> <span class="keyword">case</span> M_ARENA_TEST:</span><br><span class="line"> <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line"> mp_.arena_test = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_ARENA_MAX:</span><br><span class="line"> <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line"> mp_.arena_max = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> &#125;</span><br><span class="line"> (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<span class="comment">/*设置完成，解除主分配区的锁*/</span></span><br><span class="line"> <span class="keyword">return</span> res;<span class="comment">/*返回设置是否成功*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：mp_都没有锁，对 mp_中参数字段的修改，是通过主分配区的锁来同步的。</p>
</li>
<li><p>Ptmalloc 的初始化<br>Ptmalloc 的初始化发生在进程的第一个内存分配请求，当 ptmalloc 的初始化一般都在用<br>户的第一次调用 malloc()或 remalloc()之前，因为操作系统和 Glibc 库为进程的初始化做了不少工作，在用户分配内存以前，Glibc 已经分配了多次内存。<br>在 ptmalloc 中 malloc()函数的实际接口函数为 public_mALLOc()，这个函数最开始会执行如下的一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, __const <span class="type">__malloc_ptr_t</span>)<span class="comment">/*声明hook函数指针，从后面代码可看出，这个指针暂时拿来作为_malloc_hook_ini函数指针了*/</span></span><br><span class="line">= force_reg (__malloc_hook);<span class="comment">/*将hook函数指针赋值为__malloc_hook*/</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">/*前面写过，这个宏直接返回第一个参数，这里就相当于hook != NULL*/</span></span><br><span class="line"><span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));<span class="comment">/*执行hook函数*/</span></span><br></pre></td></tr></table></figure>
<p>在定义了__malloc_hook()全局函数的情况下，只是执行__malloc_hook()函数，在进程初始化时__malloc_hook 指向的函数为 malloc_hook_ini()（暂时的，会先赋值一份给hook，在执行malloc_hook_ini函数后会变成NULL）。注意，这里写的只是开始的一小部分代码，后面还有一堆代码，只是暂时没有写出来，可不要以为public_mALLOc函数就这点哦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*进程初始化的部分代码，声明__malloc_hook函数指针，并指向malloc_hook_ini*/</span></span><br><span class="line"><span class="type">_malloc_ptr_t</span> <span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line"><span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">__malloc_ptr_t</span>)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure>
<p>malloc_hook_ini()的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Void_t*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">malloc_hook_ini(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">__malloc_ptr_t</span> caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">malloc_hook_ini(sz, caller)</span><br><span class="line"><span class="type">size_t</span> sz; <span class="type">const</span> <span class="type">__malloc_ptr_t</span> caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*emmmm,就是不同情况下的声明方式，下面是函数的实现*/</span></span><br><span class="line">&#123;</span><br><span class="line">__malloc_hook = <span class="literal">NULL</span>;<span class="comment">/*将__malloc_hook设为NULL，原来是指向malloc_hook_ini，</span></span><br><span class="line"><span class="comment">注意hook这个函数指针并没有变哦*/</span></span><br><span class="line">ptmalloc_init();<span class="comment">/*调用ptmalloc初始化函数*/</span></span><br><span class="line"><span class="keyword">return</span> public_mALLOc(sz);<span class="comment">/*调用public_mALLOc函数（malloc的实际接口函数）*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ptmalloc_init()函数在初始化 ptmalloc 完成后，将全局变量__malloc_initialized 设置为 1，当 pbulit_mALLOc()函数再次执行时，先执行malloc_hook_ini()函数，malloc_hook_ini()函数调用 ptmalloc_init()，ptmalloc_init()函数首先判断__malloc_initialized 是否为 1，如果是，则退出 ptmalloc_init()，不再执行 ptmalloc 初始化。</p>
</li>
</ol>
<h3 id="Ptmalloc-未初始化时分配-x2F-释放内存"><a href="#Ptmalloc-未初始化时分配-x2F-释放内存" class="headerlink" title="Ptmalloc 未初始化时分配&#x2F;释放内存"></a>Ptmalloc 未初始化时分配&#x2F;释放内存</h3><p>当 ptmalloc 的初始化函数 ptmalloc_init()还没有调用之前（也就是还没有初始化ptmalloc之前），Glibc 中可能需要分配内存，比如线程私有实例的初始化需要分配内存，为了解决这一问题，ptmalloc 封装了内部的分配释放函数供在这种情况下使用。Ptmalloc 提供了三个函数，malloc_starter()，memalign_starter()，free_starter()，但没有提供 realloc_starter()函数。这几个函数的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*分配一块sz大小的内存*/</span></span><br><span class="line"><span class="type">static</span> Void_t*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">malloc_starter(<span class="type">size_t</span> sz, <span class="type">const</span> Void_t *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">malloc_starter(sz, caller) <span class="type">size_t</span> sz; <span class="type">const</span> Void_t *caller;<span class="comment">/*这个是回调函数的指针么，不知道有什么用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">Void_t* victim;<span class="comment">/*先定义一个指针，之后将其指向分配的内存*/</span></span><br><span class="line">victim = _int_malloc(&amp;main_arena, sz);<span class="comment">/*_int_malloc是ptmalloc内部函数实现，后面会详讲，只需知道是通过主分配区分配一块zs大小内存，并返回其指针。*/</span></span><br><span class="line"><span class="keyword">return</span> victim ? BOUNDED_N(victim, sz) : <span class="number">0</span>;<span class="comment">/*成功则返回指针victim，失败则返回0*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*分配一块sz大小的内存，并按align对齐*/</span></span><br><span class="line"><span class="type">static</span> Void_t*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">memalign_starter(<span class="type">size_t</span> align, <span class="type">size_t</span> sz, <span class="type">const</span> Void_t *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">memalign_starter(align, sz, caller) <span class="type">size_t</span> align, sz; <span class="type">const</span> Void_t *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">Void_t* victim;</span><br><span class="line">victim = _int_memalign(&amp;main_arena, align, sz);</span><br><span class="line"><span class="keyword">return</span> victim ? BOUNDED_N(victim, sz) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将mem指向的内存free掉*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">free_starter(Void_t* mem, <span class="type">const</span> Void_t *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">free_starter(mem, caller) Void_t* mem; <span class="type">const</span> Void_t *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">mchunkptr p;</span><br><span class="line"><span class="keyword">if</span>(!mem) <span class="keyword">return</span>;</span><br><span class="line">p = mem2chunk(mem);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">munmap_chunk(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">_int_free(&amp;main_arena, p, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_int_free(&amp;main_arena, p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述三个函数是在未初始化ptmalloc时使用的，分别对应_int_malloc,_int_memalign,_int_free</p>
<h3 id="ptmalloc-init-函数"><a href="#ptmalloc-init-函数" class="headerlink" title="ptmalloc_init()函数"></a>ptmalloc_init()函数</h3><p>该函数较长，顺序分段解析</p>
<ol>
<li><p>检查全局变量__malloc_initialized</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s;<span class="comment">/*用于环境变量读取时临时存储一些字符*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">char</span>* s;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*这里只是不同情况下的s的定义*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> secure = <span class="number">0</span>;<span class="comment">/*暂时不知道作用，看后面*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__malloc_initialized &gt;= <span class="number">0</span>) <span class="comment">/*如果全局变量__malloc_initialized == 0,表示正在初始化，&gt; 0, 表示初始化完成，两种情况下直接退出*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">__malloc_initialized = <span class="number">0</span><span class="comment">/*设置为0，表示正在初始化，防止冲突*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为多线程版本的 ptmalloc 的 pthread 初始化做准备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined SHARED &amp;&amp; !USE___THREAD</span></span><br><span class="line"><span class="comment">/* ptmalloc_init_minimal may already have been called via__libc_malloc_pthread_startup, above. */</span></span><br><span class="line"><span class="keyword">if</span> (mp_.pagesize == <span class="number">0</span>)</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">ptmalloc_init_minimal();</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_THREADS</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC</span></span><br><span class="line"><span class="comment">/* We know __pthread_initialize_minimal has already been called,and that is enough. </span></span><br><span class="line"><span class="comment">定义了_LIBC，则说明_pthread_initialize_minimal函数已经被调用过了*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> NO_STARTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_STARTER</span></span><br><span class="line"><span class="comment">/* With some threads implementations, creating thread-specific data</span></span><br><span class="line"><span class="comment">or initializing a mutex may call malloc() itself. Provide a</span></span><br><span class="line"><span class="comment">simple starter version (realloc() won‘t work). </span></span><br><span class="line"><span class="comment">ptmalloc 未初始化时，不能使用 remalloc 函数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下暂时将对应的hook函数保存起来*/</span></span><br><span class="line">save_malloc_hook = __malloc_hook;</span><br><span class="line">save_memalign_hook = __memalign_hook;</span><br><span class="line">save_free_hook = __free_hook;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*然后将hook函数设置为未初始化版本（青春版）*/</span></span><br><span class="line">__malloc_hook = malloc_starter;</span><br><span class="line">__memalign_hook = memalign_starter;</span><br><span class="line">__free_hook = free_starter;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="comment">/* Initialize the pthreads interface. </span></span><br><span class="line"><span class="comment">调用__pthread_initialize函数初始化pthread*/</span></span><br><span class="line"><span class="keyword">if</span> (__pthread_initialize != <span class="literal">NULL</span>)</span><br><span class="line">__pthread_initialize();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* !defined _LIBC */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* !defined NO_STARTER */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* !defined NO_THREADS */</span></span><br></pre></td></tr></table></figure>
<h5 id="这里插入一下-pthread-initialize函数代码"><a href="#这里插入一下-pthread-initialize函数代码" class="headerlink" title="这里插入一下__pthread_initialize函数代码"></a>这里插入一下__pthread_initialize函数代码</h5><p> 首先初始化主分配区的 mutex，并将主分配区的 next 指针指向自身组成环形链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;main_arena.mutex);</span><br><span class="line">main_arena.next = &amp;main_arena;</span><br></pre></td></tr></table></figure>
<p> 然后保证只有主分配区才能使用 sbrk()分配连续虚拟内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC &amp;&amp; defined SHARED</span></span><br><span class="line"><span class="comment">/* In case this libc copy is in a non-default namespace, never use brk.</span></span><br><span class="line"><span class="comment">Likewise if dlopened from statically linked program. </span></span><br><span class="line"><span class="comment">保证处于主分配区时才能使用sbrk分配连续的虚拟内存空间*/</span></span><br><span class="line">Dl_info di;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line"><span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">|| (_dl_addr (ptmalloc_init, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">&amp;&amp; l-&gt;l_ns != LM_ID_BASE))<span class="comment">/*一堆判断，看下面的描述*/</span></span><br><span class="line">__morecore = __failing_morecore;<span class="comment">/*__morecore 默认指向 sbrk()，指向__failing_morecore以禁用sbrk函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>大多数情况下 Glibc 库都是以动态链接库<br>的形式加载的，处于默认命名空间，多个进程共用 Glibc 库，Glibc 库代码段在内存中只有一份拷贝，数据段在每个用户进程都有一份拷贝。但如果 Glibc 库不在默认名字空间，或是用户程序是静态编译的并调用了 dlopen 函数加载 Glibc 库中的 ptamalloc_init()，这种情况下的ptmalloc 不允许使用 sbrk()分配内存，只需修改__morecore 函数指针指向__failing_morecore就可以禁止使用 sbrk()了，__morecore 默认指向 sbrk()。</p>
</li>
</ol>
<p> 最后执行几个初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化全局锁list_lock*/</span></span><br><span class="line">mutex_init(&amp;list_lock);<span class="comment">/*list_lock 主要用于同步分配区的单向循环链表*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建线程私有实例 arena_key*/</span></span><br><span class="line">tsd_key_create(&amp;arena_key, <span class="literal">NULL</span>);<span class="comment">/*该私有实例保存的是分配区（arena）的 malloc_state 实例指针*/</span></span><br><span class="line"></span><br><span class="line">tsd_setspecific(arena_key, (Void_t *)&amp;main_arena);<span class="comment">/*将arena_key 绑定到主分配区上。意味着本线程首选从主分配区分配内存。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用 thread_atfork()设置当前进程在 fork 子线程时处理 mutex 的回调函数*/</span></span><br><span class="line">thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</span><br></pre></td></tr></table></figure>
<p>thread_atfork的详细解释：在本进程fork子线程时，调用ptmalloc_lock_all()获得所有分配区的锁，禁止所有分配区分配内存，当子线程创建完毕，父进程调用ptmalloc_unlock_all()重新unlock 每个分配区的锁mutex，子线程调用ptmalloc_unlock_all2()重新初始化每个分配区的锁 mutex。</p>
<h5 id="继续讲ptmalloc-init函数"><a href="#继续讲ptmalloc-init函数" class="headerlink" title="继续讲ptmalloc_init函数"></a>继续讲ptmalloc_init函数</h5><ol start="3">
<li><p>当 pthread 初始化完成后，将相应的 hooks 函数还原为原值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_THREADS</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_STARTER</span></span><br><span class="line">__malloc_hook = save_malloc_hook;</span><br><span class="line">__memalign_hook = save_memalign_hook;</span><br><span class="line">__free_hook = save_free_hook;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">undef</span> NO_STARTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>从环境变量中读取相应的配置参数值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">secure = __libc_enable_secure;</span><br><span class="line">s = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (_environ != <span class="literal">NULL</span>, <span class="number">1</span>))<span class="comment">/*如果环境变量非空*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> **runp = _environ;</span><br><span class="line"><span class="type">char</span> *envline;</span><br><span class="line"><span class="keyword">while</span> (__builtin_expect ((envline = next_env_entry (&amp;runp)) != <span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strcspn</span> (envline, <span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (envline[len] != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="comment">/* This is a &quot;MALLOC_&quot; variable at the end of the string</span></span><br><span class="line"><span class="comment">without a &#x27;=&#x27; character. Ignore it since otherwise we</span></span><br><span class="line"><span class="comment">will access invalid memory below. */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">switch</span> (len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;CHECK_&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">s = &amp;envline[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TOP_PAD_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_TOP_PAD, atoi(&amp;envline[<span class="number">9</span>]));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;PERTURB_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_PERTURB, atoi(&amp;envline[<span class="number">9</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_MAX_&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_MMAP_MAX, atoi(&amp;envline[<span class="number">10</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_MAX&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_ARENA_MAX, atoi(&amp;envline[<span class="number">10</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_TEST&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_ARENA_TEST, atoi(&amp;envline[<span class="number">11</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TRIM_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_TRIM_THRESHOLD, atoi(&amp;envline[<span class="number">16</span>]));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_MMAP_THRESHOLD, atoi(&amp;envline[<span class="number">16</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_TRIM_THRESHOLD_&quot;</span>)))</span><br><span class="line">mALLOPt(M_TRIM_THRESHOLD, atoi(s));</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_TOP_PAD_&quot;</span>)))</span><br><span class="line">mALLOPt(M_TOP_PAD, atoi(s));</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_PERTURB_&quot;</span>)))</span><br><span class="line">mALLOPt(M_PERTURB, atoi(s));</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_MMAP_THRESHOLD_&quot;</span>)))</span><br><span class="line">mALLOPt(M_MMAP_THRESHOLD, atoi(s));</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_MMAP_MAX_&quot;</span>)))</span><br><span class="line">mALLOPt(M_MMAP_MAX, atoi(s));</span><br><span class="line">&#125;</span><br><span class="line">s = getenv(<span class="string">&quot;MALLOC_CHECK_&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span>(s &amp;&amp; s[<span class="number">0</span>]) &#123;</span><br><span class="line">mALLOPt(M_CHECK_ACTION, (<span class="type">int</span>)(s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="keyword">if</span> (check_action != <span class="number">0</span>)</span><br><span class="line">__malloc_check_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些参数包括 MALLOC_TRIM_THRESHOLD_，MALLOC_TOP_PAD_，MALLOC_PERTURB_，MALLOC_MMAP_THRESHOLD_，MALLOC_CHECK_MALLOC_MMAP_MAX_，MALLOC_ ARENA_MAX,MALLOC_ ARENA_TEST,如果这些选项中的某些项存在，调用 mallopt()函数设置相应的选项。如果这段程序是在 Glibc 库初始化中执行的，会做更多的安全检查工作。仅仅是配置环境变量，不必过于关心。</p>
</li>
<li><p>最后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__malloc_initialize_hook);</span><br><span class="line"><span class="keyword">if</span> (hook != <span class="literal">NULL</span>)<span class="comment">/*查看是否存在__malloc_initialize_hook 函数*/</span></span><br><span class="line">(*hook)();<span class="comment">/*存在，则执行*/</span></span><br><span class="line">__malloc_initialized = <span class="number">1</span>;<span class="comment">/*设为1，表示初始化完成*/</span></span><br></pre></td></tr></table></figure>
<p>注意这里是在ptmalloc当中的hook变量，之前那个是在public_mALLOc函数里面，用一幅图来描述初始化过程：</p>
</li>
</ol>
<p><img src="/images/images/ptmalloc_ini.png" alt="alt ptmalloc_ini"></p>

    </div>

    
    
    

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">'''没有了哦=V='''</div>
    
</div>
  
</div>

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/16/cs_major/" rel="prev" title="CS作业预测及解析">
      <i class="fa fa-chevron-left"></i> CS作业预测及解析
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ptmalloc%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">ptmalloc的设计概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ptmalloc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%81%87%E8%AE%BE"><span class="nav-number">1.0.1.</span> <span class="nav-text">ptmalloc内存管理的设计假设</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.0.2.</span> <span class="nav-text">内存管理的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Main-arena-%E4%B8%8E-non-main-arena"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">Main_arena 与 non_main_arena</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk"><span class="nav-number">1.0.3.</span> <span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2chunk%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">1.0.4.</span> <span class="nav-text">空闲chunk的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sbrk%E4%B8%8Emmap"><span class="nav-number">1.0.5.</span> <span class="nav-text">sbrk与mmap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">内存分配概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%A6%82%E4%B8%8B%E7%9A%84%E5%9B%BE%E6%9D%A5%E6%8F%8F%E8%BF%B0malloc%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">2.0.1.</span> <span class="nav-text">用如下的图来描述malloc的流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%9D%A5%E6%8F%8F%E8%BF%B0free%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">2.0.2.</span> <span class="nav-text">用如下图来描述free的流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.0.3.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ptmalloc%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-gt-lt"><span class="nav-number">3.</span> <span class="nav-text">ptmalloc的源代码分析(&gt;_&lt;)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">3.0.1.</span> <span class="nav-text">chunk及其相关宏和数据结构的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bins%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">3.0.2.</span> <span class="nav-text">bins及其相关源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Small-bins"><span class="nav-number">3.0.2.1.</span> <span class="nav-text">Small bins</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Large-bins"><span class="nav-number">3.0.2.2.</span> <span class="nav-text">Large bins</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E5%AF%B9bins%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%8F"><span class="nav-number">3.0.2.3.</span> <span class="nav-text">几个对bins的操作宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unsorted-bin"><span class="nav-number">3.0.2.4.</span> <span class="nav-text">Unsorted bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fast-bins"><span class="nav-number">3.0.2.5.</span> <span class="nav-text">Fast bins</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90"><span class="nav-number">3.0.3.</span> <span class="nav-text">核心结构体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-state"><span class="nav-number">3.0.3.1.</span> <span class="nav-text">malloc_state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Malloc-par"><span class="nav-number">3.0.3.2.</span> <span class="nav-text">Malloc_par</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%8C%BA%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.0.4.</span> <span class="nav-text">分配区的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ptmalloc-%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%88%86%E9%85%8D-x2F-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="nav-number">3.0.5.</span> <span class="nav-text">Ptmalloc 未初始化时分配&#x2F;释放内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ptmalloc-init-%E5%87%BD%E6%95%B0"><span class="nav-number">3.0.6.</span> <span class="nav-text">ptmalloc_init()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%99%E9%87%8C%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%8B-pthread-initialize%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">3.0.6.0.1.</span> <span class="nav-text">这里插入一下__pthread_initialize函数代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E7%BB%AD%E8%AE%B2ptmalloc-init%E5%87%BD%E6%95%B0"><span class="nav-number">3.0.6.0.2.</span> <span class="nav-text">继续讲ptmalloc_init函数</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Limiter"
      src="/images/doge.jpg">
  <p class="site-author-name" itemprop="name">Limiter</p>
  <div class="site-description" itemprop="description">maybe ordinary people don't always crack</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Limiter</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="maybe ordinary people don&#39;t always crack">
<meta property="og:type" content="website">
<meta property="og:title" content="L1m1t3r&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="L1m1t3r&#39;s Blog">
<meta property="og:description" content="maybe ordinary people don&#39;t always crack">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Limiter">
<meta property="article:tag" content="ctf,cs,pwn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>L1m1t3r's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">L1m1t3r's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">水水水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="Limiter">
      <meta itemprop="description" content="maybe ordinary people don't always crack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1m1t3r's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/17/ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ptmalloc源码分析笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-17 12:33:24" itemprop="dateCreated datePublished" datetime="2022-05-17T12:33:24+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-21 02:08:39" itemprop="dateModified" datetime="2022-05-21T02:08:39+08:00">2022-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ptmalloc的设计概述"><a href="#ptmalloc的设计概述" class="headerlink" title="ptmalloc的设计概述"></a>ptmalloc的设计概述</h1><h3 id="ptmalloc内存管理的设计假设"><a href="#ptmalloc内存管理的设计假设" class="headerlink" title="ptmalloc内存管理的设计假设"></a>ptmalloc内存管理的设计假设</h3><p>ptmalloc的设计假设是对于ptmalloc的基本行为概述，可以从宏观层面掌握ptmalloc在内存分配中采取的行为。  </p>
<ol>
<li>具有长周期的大内存分配使用mmap<a href="mmap%E5%92%8Cbrk%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%96%B9%E5%BC%8F%EF%BC%8Cmmap%E6%98%AF%E9%80%9A%E8%BF%87mmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9B%B4%E6%8E%A5%E7%94%B3%E8%AF%B7%E4%B8%80%E5%9D%97%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%80%8Cbrk%E6%98%AF%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%94%B9%E5%8F%98%E5%86%85%E6%A0%B8%E4%B8%ADmm_struct(%E6%8F%8F%E8%BF%B0%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%93%E6%9E%84)%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84brk%E5%80%BC%EF%BC%8C%E6%9D%A5%E6%9B%B4%E6%94%B9heap%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BB%8E%E8%80%8C%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A4%9A%E7%A9%BA%E9%97%B4%E3%80%82%EF%BC%88%E6%AD%A4%E5%A4%96mmap%E5%9C%A8ptmalloc%E4%B8%AD%E6%80%BB%E6%98%AF%E6%98%A0%E5%B0%84%E5%8C%BF%E5%90%8D%E6%95%B0%E6%8D%AE%E6%AE%B5%EF%BC%89">^1</a>。</li>
<li>特别大的内存分配总是使用mmap。</li>
<li>具有短周期的内存分配使用brk。</li>
<li>尽量只缓存临时使用的空闲小内存块，对大内存或者长周期的大内存在释放时都直接还给操作系统。</li>
<li>对空闲的小内存块只会在malloc和free的时候进行合并<a href="%E5%90%88%E5%B9%B6%E6%98%AF%E6%8C%87%E5%AF%B9%E7%89%A9%E7%90%86%E7%9B%B8%E9%82%BB%E7%9A%84chunk%E5%90%88%E5%B9%B6%EF%BC%8C%E5%B9%B6%E9%9D%9E%E6%8C%87%E5%AF%B9bins%E4%B8%AD%E7%9B%B8%E9%82%BB%E7%9A%84chunk%E5%90%88%E5%B9%B6">^1.1</a>,free时空闲内存块可能会放入pool中，不一定返还给操作系统。</li>
<li>收缩堆的条件是当前free的块的大小加上前后能合并的thunk大小大于64kb，并且堆顶的大小达到阈值，才会把堆最顶端的空闲内存返还给操作系统。</li>
<li>多个线程可以从同一个分配区（arena）中分配内存，ptmalloc假设A线程释放一块内存后，线程B会申请类似大小的内存，但是A释放的内存跟B需要的内存并不一定完全相等，可能会有一个小误差，就需要不断对内存块进行切割和合并，这个过程可能会产生内存碎片。</li>
</ol>
<h3 id="内存管理的数据结构"><a href="#内存管理的数据结构" class="headerlink" title="内存管理的数据结构"></a>内存管理的数据结构</h3><h4 id="Main-arena-与-non-main-arena"><a href="#Main-arena-与-non-main-arena" class="headerlink" title="Main_arena 与 non_main_arena"></a>Main_arena 与 non_main_arena</h4><p>每个进程都有一个主分配区和多个非主分配区<a href="%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E9%87%8F%E6%9C%89%E5%85%B3">^2</a>, 非主分配区的出现是为了减少多线程下对分配区的竞争。主分配区能使用mmap和sbrk进行内存管理，非主分配区只能使用mmap。分配区<a href="%E5%88%86%E9%85%8D%E5%8C%BA%E5%B9%B6%E9%9D%9E%E6%8C%87%E8%A6%81%E8%A2%AB%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%87%E8%83%BD%E5%A4%9F%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%89">^3</a>一旦增加就不会再减少。</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>用户请求分配的空间在 ptmalloc 中都使<br>用一个 chunk 来表示。用户调用 free()函数释放掉的内存也并不是立即就归还给操作系统，，它们也会被表示为一个 chunk，ptmalloc 使用特定的数据结构来管理这些空闲的 chunk。chunk的结构如下:<br><img src="https://github.com/Lucky-force/Lucky-force.github.io/tree/main/images/imges/chunk.PNG" alt="alt chunk"><br>chunk的结构和特性在《glibc内存管理ptmalloc源代码分析》中写的十分详细，此处不再复述。本文主要是对于该文章中源代码分析部分过于简略且难以理解的部分作出补充。</p>
<h3 id="空闲chunk的容器"><a href="#空闲chunk的容器" class="headerlink" title="空闲chunk的容器"></a>空闲chunk的容器</h3><p>ptmalloc使用bins来管理空闲的chunk。（请参考原作部分）</p>
<h3 id="sbrk与mmap"><a href="#sbrk与mmap" class="headerlink" title="sbrk与mmap"></a>sbrk与mmap</h3><p>前文提到过，malloc分配内存时，对于主分配区而言，既能使用mmap来直接映射新内存，也能通过改变brk值来扩展heap。其不同分配方式的条件如下：</p>
<ol>
<li>ptmalloc在开始时，若请求的空间小于 mmap分配阈值（mmap threshold，默认值为 128KB）时，主分配区会调用 sbrk()增加一块大小为 (128 KB + chunk_size) align 4KB 的空间作为 heap。非主分配区会调用 mmap 映射一块大小为HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。</li>
<li>当用户请求内存分配时，首先会在这个空间内找一块合适的 chunk 给用户。当用户释放了 heap 中的 chunk 时，ptmalloc 又会使用 fastbins 和 bins 来组织空闲 chunk。以备用户的下一次分配。</li>
<li>若需要分配的 chunk 大小小于 mmap分配阈值，而 heap 空间又不够，则此时主分配区会通过 sbrk()调用来增加 heap 大小，非主分配区会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到 4KB。</li>
<li>当用户的请求超过 mmap 分配阈值，ptmalloc 会尝试使用 mmap()直接映射一块内存到进程内存空间。使用 mmap()直接映射的 chunk 在释放时直接解除映射，而不再属于进程的内存空间。任何对该内存的访问都会产生段错误。而在heap 中或是 sub-heap 中分配的空间则可能会留在进程内存空间内，还可以再次引用（当然是很危险的）。</li>
<li>当 ptmalloc munmap chunk 时，如果回收的 chunk 空间大小大于 mmap 分配阈值的当前值，并且小于DEFAULT_MMAP_THRESHOLD_MAX（32 位系统默认为 512KB，64 位系统默认为 32MB），ptmalloc 会把 mmap 分配阈值调整为当前回收的 chunk 的大小，并将 mmap 收缩阈值（mmap trim threshold）设置为 mmap 分配阈值的 2 倍。这就是 ptmalloc 的对 mmap分配阈值的动态调整机制，该机制是默认开启的，当然也可以用 mallopt()关闭该机制。</li>
</ol>
<h1 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h1><h3 id="用如下的图来描述malloc的流程："><a href="#用如下的图来描述malloc的流程：" class="headerlink" title="用如下的图来描述malloc的流程："></a>用如下的图来描述malloc的流程：</h3><p><img src="https://github.com/Lucky-force/Lucky-force.github.io/tree/main/images/imges/malloc.png" alt="alt malloc"></p>
<h3 id="用如下图来描述free的流程："><a href="#用如下图来描述free的流程：" class="headerlink" title="用如下图来描述free的流程："></a>用如下图来描述free的流程：</h3><p><img src="https://github.com/Lucky-force/Lucky-force.github.io/tree/main/images/imges/free.png" alt="alt free"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ptmalloc同样具有函数mallopt()来配置选项，此处不再细写。</p>
<h1 id="ptmalloc的源代码分析-gt-lt"><a href="#ptmalloc的源代码分析-gt-lt" class="headerlink" title="ptmalloc的源代码分析(&gt;_&lt;)"></a>ptmalloc的源代码分析(&gt;_&lt;)</h1><p>此段用于对《glibc内存管理ptmalloc源代码分析》中的源码部分进行更加详细的注释（原作的代码部分注释过于简略，对很多凭空出现的变量没有指明其作用）。</p>
<h3 id="chunk及其相关宏和数据结构的声明"><a href="#chunk及其相关宏和数据结构的声明" class="headerlink" title="chunk及其相关宏和数据结构的声明"></a>chunk及其相关宏和数据结构的声明</h3><ol>
<li>chunk的声明<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"> INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). </span></span><br><span class="line"><span class="comment">                            前一个chunk的大小（如果前一个chunk是空闲的，否则无意义）*/</span></span><br><span class="line"> INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. </span></span><br><span class="line"><span class="comment">                        大小占多少byte，包括了开销（即除了用户能使用的空间之外用于表示chunk信息的额外空间，chunk具有空间复用，根据chunk是否空闲来具体分析其overhead）*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. </span></span><br><span class="line"><span class="comment">                          双向链表指针，只有chunk空闲的时候有用*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"> <span class="comment">/* Only used for large blocks: pointer to next larger size. </span></span><br><span class="line"><span class="comment"> 只用于large bin中的大块chunk，指向下一个更大的chunk*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. </span></span><br><span class="line"><span class="comment">                                    用于双向链表，只在chunk空闲时有用*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
2.相关转换和检查的宏<br>声明：指向chunk的指针指的是指向chunk头的指针，而指向mem的指针指的是指向用户存储数据的空间的指针（请结合上面那幅chunk的图查看）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back </span></span><br><span class="line"><span class="comment">chunk头指针到用户使用空间指针的来回转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((Void_t*)((char*)(p) + 2*SIZE_SZ)) <span class="comment">/* p代表指向chunk头的指针，这个宏将其转换为用户能使用的空间的指针（就是让p跳过sizeofprev和size）*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))<span class="comment">/*mem代表指向用户空间的指针，这个宏将其转换为chunk头的指针*/</span></span></span><br><span class="line"><span class="comment">/* The smallest possible chunk </span></span><br><span class="line"><span class="comment">最小的可能chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))<span class="comment">/*offsetof(a, b),求b在a中的偏移，这里fd_nextsize的偏移正好是最小chunk的大小*/</span></span></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk </span></span><br><span class="line"><span class="comment">我们可以分配的最小chunk是一个对齐的极小chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE \</span></span><br><span class="line"><span class="meta"> (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))<span class="comment">/*对min_chunk_size进行了2*SIZE_SZ对齐，不必过于关心*/</span></span></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment </span></span><br><span class="line"><span class="comment">检查m是否对齐*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta"> ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta"> &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>这几个宏用于将用户请求的分配大小转换成内部需要分配的 chunk 大小，这里需要注意的在转换时不但考虑的地址对齐，还额外加上了 SIZE_SZ，这意味着 ptmalloc 分配内存需要一个额外的overhead，为SIZE_SZ字节，通过chunk的空间复用，我们很容易得出这个overhead为 SIZE_SZ。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment"> padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment"> low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> 检查请求值是否过大以至于在填充和对齐时会发生溢出（原文是零环绕，我觉得溢出更好理解，可能有错&gt;_&lt;）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req) \</span></span><br><span class="line"><span class="meta"> ((unsigned long)(req) &gt;= \</span></span><br><span class="line"><span class="meta"> (unsigned long)(INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version </span></span><br><span class="line"><span class="comment">将请求的内存值转换为应当分配的chunk大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req) \</span></span><br><span class="line"><span class="meta">31</span></span><br><span class="line"> (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \</span><br><span class="line"> MINSIZE : \</span><br><span class="line"> ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"><span class="comment">/* Same, except also perform argument check </span></span><br><span class="line"><span class="comment">这个宏实际上是将上面两个结合起来，先判断是否超过范围，在根据判断返回应当分配的chunk大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta"> <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123; \</span></span><br><span class="line"><span class="meta"> MALLOC_FAILURE_ACTION; \</span></span><br><span class="line"><span class="meta"> return 0; \</span></span><br><span class="line"><span class="meta"> &#125; \</span></span><br><span class="line"><span class="meta"> (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>chunk 在分割时总是以地址对齐（默认是 8 字节，可以自由设置，但是 8 字节是最小值并且设置的值必须是 2 为底的幂函数值，即是 alignment &#x3D; 2^n，n 为整数且 n&gt;&#x3D;3）的方式来进行的，所以用 chunk-&gt;size 来存储本 chunk 块大小字节数的话，其末 3bit 位总是 0，因此这三位可以用来存储其它信息,以下是对这三位的设置宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use </span></span><br><span class="line"><span class="comment">前一个chunk为使用中，则P位设为1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk </span></span><br><span class="line"><span class="comment">抽取前一个chunk的inuse位（即当前chunk的P位）（p是chunk头指针）（前一个chunk是否空闲是由它下一个chunk的P位决定的）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() </span></span><br><span class="line"><span class="comment">该chunk由mmap分配而来，则M位设为1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk </span></span><br><span class="line"><span class="comment">检查chunk是否由mmap分配*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment"> from a non-main arena. This is only set immediately before handing</span></span><br><span class="line"><span class="comment"> the chunk to the user, if necessary. </span></span><br><span class="line"><span class="comment"> 该chunk属于非主分配区，则A位设为1，如果必要的话，只在将chunk交给用户之前即刻设置*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena </span></span><br><span class="line"><span class="comment">检查chunk是否来自非主分配区*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以下是有关定位chunk的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义SIZE_BITS，用于去掉后三位的影响，返回chunk实际大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits </span></span><br><span class="line"><span class="comment">得到chunk大小，忽略控制信息*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. </span></span><br><span class="line"><span class="comment">返回p指向的chunk物理地址上下一个chunk的指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk </span></span><br><span class="line"><span class="comment">返回p指向的chunk物理地址上上一个chunk的指针（只有在前一个chunk空闲时这个宏才有意义（看代码实现就知道了哦））*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk </span></span><br><span class="line"><span class="comment">返回p+s，将p+s处的空间当作一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用于设置&#x2F;检查&#x2F;清除chunk使用标志位的宏<br>注意：当前chunk的使用标志位储存在下一个chunk里面（P位）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit </span></span><br><span class="line"><span class="comment">抽取p指向chunk的inuse位（当前chunk的inuse位是下一个chunk的P位）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)\</span></span><br><span class="line"><span class="meta">((((mchunkptr)(((char*)(p))+((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing </span></span><br><span class="line"><span class="comment">设置或清除p所指向chunk的inuse位*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>7.设置，检查，清除指定chunk中的inuse位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places </span></span><br><span class="line"><span class="comment">设置，检查，清除指定chunk中的inuse位*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span></span><br><span class="line"><span class="comment">/*就是把p+s指向的空间当作一个chunk，然后把设置P位（感觉有点怪，明明设置的是P位，却叫inuse位设置宏）*/</span></span><br></pre></td></tr></table></figure>
<p>8.设置chunk的size的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit </span></span><br><span class="line"><span class="comment">直接设置chunk（由p指向）的szie域为s，并保留原来的控制信息*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s) ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"><span class="comment">/* Set size/use field </span></span><br><span class="line"><span class="comment">直接设置chunk的size域为s*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;size = (s))</span></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) </span></span><br><span class="line"><span class="comment">将foot的值设置为s*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s) (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：前面有所提到，foot就是下一个chunk保存其物理相邻的上一个空闲chunk大小的位置，由于s正是要设置的chunk大小，所以set_foot宏用p+s定位到下一个chunk的prev_size域。</p>
<h3 id="bins及其相关源码解析"><a href="#bins及其相关源码解析" class="headerlink" title="bins及其相关源码解析"></a>bins及其相关源码解析</h3><h4 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h4><p>Small bins在bins的数组（其实不准确，以下会有说明）中从下标2开始，一直到下标65，一共有64个，但一般实际用到的只有62个（最后两个不用）。每个Small bin是一个链表头，包括malloc_chunk* fd 和 malloc_chunk* bk两个指针。注意，由于源码中拥有上述两个指针的是malloc_chunk结构体，在编写代码的时候，一个指向malloc_chunk结构体的指针可以直接引用其中的元素，但如果每个bin都定义为一个malloc_chunk,其mem，size，prev_size空间都没有用，实际上就浪费了，因此直接定义一个256大小的指针数组（bin有128个），每个元素是malloc_chunk* 指针，用两个元素代表一个bin（fd和bk），但是又用一个malloc_chunk指针p指向bin向前偏移2个SIZE_SZ的位置（或者说指向该bin的上一个bin），这样就可以用p-&gt;fd和p-&gt;bk来直接引用这两个指针，更为方便和易读，如下图<br><img src="https://github.com/Lucky-force/Lucky-force.github.io/tree/main/images/imges/bins.png" alt="alt bins"></p>
</li>
</ol>
<p>注意：以下的下标（index）都是表示bin的下标而非数组元素的下标<br>ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index有如下关系：</p>
<p>Chunk_size&#x3D;2 * SIZE_SZ * index（SIZE_SZ可看作当前系统指针的大小，反正数值一样）</p>
<p>ptmalloc 维护了 62 个双向环形链表（每个链表都具有链表头节点，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲 chunk 的大小一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可以用如下图来表示在 SIZE_SZ 为 4B 的平台上 ptmalloc 对 512B 字节以下的空闲 chunk 组织方式（所谓的分箱机制）<br><img src="https://github.com/Lucky-force/Lucky-force.github.io/tree/main/images/imges/small_bins.png" alt="alt small_bins"></p>
<h4 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h4><p>在 SIZE_SZ 为 4B 的平台上，大于等于 512B 的空闲 chunk，或者，在 SIZE_SZ 为 8B 的平台上，大小大于等于 1024B 的空闲 chunk，由 sorted bins 管理。Large bins 一共包括 63 个 bin，每个 bin 中的 chunk 大小不是一个固定公差的等差数列，而是分成 6 组 bin，每组 bin 是一个固定公差的等差数列，每组的 bin 数量依次为 32、16、8、4、2、1，公差依次为 64B、512B、4096B、32768B、262144B 等.<br>以 SIZE_SZ 为 4B 的平台为例，第一个 large bin 的起始 chunk 大小为 512B，共 32 个 bin，公差为 64B，等差数列满足如下关系：Chunk_size&#x3D;512 + 64 * index<br>第二个 large bin 的起始 chunk 大小为第一组 bin 的结束 chunk 大小，满足如下关系：<br>Chunk_size&#x3D;512 + 64 * 32 + 512 * index<br>同理，我们可计算出每个 bin 的起始 chunk 大小和结束 chunk 大小。这些 bin 都是很有规律的，其实 small bins 也是满足类似规律，small bins 可以看着是公差为 8 的等差数列，一共有 64 个 bin（第 0 和 1bin 不存在），所以我们可以将 small bins 和 large bins 存放在同一个包含 128 个 chunk 的数组上，数组的前一部分位 small bins，后一部分为 large bins，每个 bin的 index 为 chunk 数组的下标，于是，我们可以根据数组下标计算出该 bin 的 chunk 大小（smallbins）或是 chunk 大小范围（large bins），也可以根据需要分配内存块大小计算出所需 chunk所属 bin 的 index，ptmalloc 使用了一组宏巧妙的实现了这种计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128  <span class="comment">/*定义了bin的数量*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64 <span class="comment">/*定义了small_bin的数量*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT <span class="comment">/*malloc_alignment 定义为 2*SIZE_SZ,是用来处理chunk地址对齐的宏*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE (NSMALLBINS * SMALLBIN_WIDTH) <span class="comment">/*定义最小的Large chunk大小*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta"> ((unsigned long)(sz) <span class="string">&lt; (unsigned long)MIN_LARGE_SIZE) /*这个宏用于判断sz（p-&gt;</span>size）的大小是否属于small chunk的范围*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta"> (SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) &gt;&gt; 4) : (((unsigned)(sz)) &gt;&gt; 3))<span class="comment">/*通过chunk的大小返回其在small bins中的index（从2开始）*/</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*以下分别是32位和64位下根据size大小返回其在Large bins 中index（从66开始）的宏*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 38)? 56 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20)? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta"> 126)</span></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48)? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">36</span></span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)? <span class="number">91</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)? <span class="number">110</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)? <span class="number">119</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)? <span class="number">124</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>): \</span><br><span class="line"> <span class="number">126</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta"> (SIZE_SZ == 8 ? largebin_index_64 (sz) : largebin_index_32 (sz))<span class="comment">/*这个宏是把上面的两个结合起来，直接通过size返回在large bins中的index（无关操作系统位数）*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))<span class="comment">/*这个是上面宏的最后缝合体，直接通过size返回bins中的index*/</span></span></span><br></pre></td></tr></table></figure>

<h4 id="几个对bins的操作宏"><a href="#几个对bins的操作宏" class="headerlink" title="几个对bins的操作宏"></a>几个对bins的操作宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mbinptr</span>;</span><span class="comment">/*后面的源代码常用这里的定义，建议记住</span></span><br><span class="line"><span class="comment">是malloc_bin_pointer的简写，前面讲过了bin的访问方式*/</span></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist </span></span><br><span class="line"><span class="comment">通过index返回bin的地址，注意，bin_at(0)不存在*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \<span class="comment">/*m是malloc_state结构体指针，后面会讲，这里面放着bins数组，i就是传入的index*/</span></span></span><br><span class="line"> (mbinptr) (((<span class="type">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>])) \</span><br><span class="line"> - offsetof (<span class="keyword">struct</span> malloc_chunk, fd))<span class="comment">/*这个offsetof前面也有讲过，这段代码仔细看看就理解了*/</span></span><br><span class="line"><span class="comment">/* 返回b指向bin的下一个bin的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char*)(b) + (sizeof(mchunkptr)&lt;&lt;1)))<span class="comment">/*sizeof（mchunkptr）&lt;&lt;1其实就是8&lt;&lt;1 == 16,正好是两个bin之间的距离*/</span></span></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins </span></span><br><span class="line"><span class="comment">bin中的第一个chunk和最后一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)<span class="comment">/*bin维护的是双向链表哦*/</span></span></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list </span></span><br><span class="line"><span class="comment">将一个chunk从bin维护的双向链表中摘下*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; \<span class="comment">/*这里传BK和FD就是为了让你传个载体，毕竟宏里面不好定义新变量*/</span></span></span><br><span class="line"> FD = P-&gt;fd; \</span><br><span class="line"> BK = P-&gt;bk; \</span><br><span class="line"> <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) \<span class="comment">/*这是一个判断宏，__builtin_expect(a,b),若a == b则返回1，这里就是判断传入的p所指向的chunk是否真的在双向链表中*/</span></span><br><span class="line"> malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); \<span class="comment">/*打印错误信息*/</span></span><br><span class="line"> <span class="keyword">else</span> &#123; \</span><br><span class="line"> FD-&gt;bk = BK; \</span><br><span class="line"> BK-&gt;fd = FD; \<span class="comment">/*将chunk取出*/</span></span><br><span class="line"> <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) \</span><br><span class="line"> &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123; \<span class="comment">/*若P所指向的chunk不在small bin中且该chunk有fd_nextsize指针（说明是large chunk）*/</span></span><br><span class="line"> <span class="comment">/*以下是当为large chunk时，还需要做的操作（从横向循环链表中删除）*/</span></span><br><span class="line"> assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); \</span><br><span class="line"> assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); \</span><br><span class="line"> <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123; \</span><br><span class="line"> <span class="keyword">if</span> (P-&gt;fd_nextsize == P) \</span><br><span class="line"> FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \</span><br><span class="line"> <span class="keyword">else</span> &#123; \</span><br><span class="line"> FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span><br><span class="line"> FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span><br><span class="line"> P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \</span><br><span class="line"> P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line"> P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span><br><span class="line"> P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/cs_major/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="Limiter">
      <meta itemprop="description" content="maybe ordinary people don't always crack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1m1t3r's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/cs_major/" class="post-title-link" itemprop="url">CS作业预测及解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-16 13:17:38 / 修改时间：17:47:06" itemprop="dateCreated datePublished" datetime="2022-05-16T13:17:38+08:00">2022-05-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今年的预测难度可谓是大的离谱，当我看到x队，黑豹和小火苗这些强队被绿龙打的毫无换手之力时，我就知道这届比赛必定是爆冷连连。果不其然，失去了阿汤哥的NIP竟然开始发挥，3爷的狙也逐渐变得离谱，在加上小蜜蜂的疯狂拉跨，相信很多人的作业已经是接近凉凉。<br>不过好在navi依然稳的一比，直接3：0晋级（不会有人没选navi吧），让大多数人有了一丝机会。以下是剩余队伍的获胜概率分析，以及什么样的作业可以挺过这一轮恐怖的传奇组比赛。</p>
<h2 id="以下是我认为接下来比较可能晋级的队伍"><a href="#以下是我认为接下来比较可能晋级的队伍" class="headerlink" title="以下是我认为接下来比较可能晋级的队伍"></a>以下是我认为接下来比较可能晋级的队伍</h2><h3 id="X队（Heroic）"><a href="#X队（Heroic）" class="headerlink" title="X队（Heroic）"></a>X队（Heroic）</h3><p>最近几场比赛x队的发挥都一如既往的稳定，输给绿龙完全是因为绿龙发挥过于离谱，而且是bo1赛制，具有一定的运气成分。尼的步枪一直很刚，加上卡点也开始发挥，尤其是对战G2的比赛，在大比分落后且被G2先拿到赛点，以及处于打匪的劣势的情况下稳住心态，逐步反超，可见其无论是战术还是枪法心态都处于非常不错的状态。因此x队的晋级似乎是必然的。</p>
<h3 id="黑豹"><a href="#黑豹" class="headerlink" title="黑豹"></a>黑豹</h3><p>黑豹作为一支非常规战术以及个人能力都十分出色的战队，在传奇组的关键比赛中将要对战状态正好的NIP，NIP在对战navi之前可谓是风头极盛，但在与navi的比赛中被打击了一下。假如NIP的这次挫败并没有影响他们的火热手感，那么当前状态的黑豹是很难获胜的，除非arT和优瑞这两名大哥超常发挥，（尤其是arT）在非常规和干摸绕后中狠狠的偷NIP的屁股以打击他们的心态和手感。</p>
<h3 id="G2"><a href="#G2" class="headerlink" title="G2"></a>G2</h3><p>G2最近的两场落败都令人十分惋惜，无论是面对navi还是Heroic，都在jackz和表哥的发挥下打出了很大的优势，反观NIKO，已经很长时间没有发挥了，可以从NIKO多次的白给中发现其心态有些问题，似乎小李子的战术布局让NIKO的个人能力不能很好的发挥，并且在开局掉人或陷入劣势的情况下，NIKO希望凭借个人能力创造机会，从而更容易白给，使队友残局变得异常困难，我个人认为是monesy并没有完全弥补G2狙击手的短板，虽然年仅17岁的他操作犀利，上限极高，而且常常在残局1Vn，但在每局比赛中的开局打的过于稳建，在场上的站位也有些死板，并非是说monesy的实力和意识不足，从他的日常训练视频中可以看出他不逊色于s1mple的狙击技术和灵性。但在比赛时，过于年轻的monesy害怕由于自己的死亡而拖累队友，因此打的比较保守，反而在残局阶段和eco或强起时释放自我，往往打出逆天操作。今晚的G2对阵VP可以说只要G2不犯病或者被连续的失败打击了状态，基本是稳赢。但要想晋级，则需要和剩下的强队较量一番，以其实力来说是没有问题的，但G2的发挥和赛点犯病总是令人担忧。</p>
<h3 id="Faze"><a href="#Faze" class="headerlink" title="Faze"></a>Faze</h3><p>刚战胜的宿敌C9的Faze状态正好，只能说今晚战胜小火苗晋级是必然的事，选Faze是必然稳的（Faze输了的话就当我是sb）</p>
<h3 id="C9"><a href="#C9" class="headerlink" title="C9"></a>C9</h3><p>作为红星的躯壳，C9的复活似乎正是为了阻止Faze夺冠而来，无论是队伍实力还是情怀问题，选C9是不用犹豫的。</p>
<h3 id="NIP"><a href="#NIP" class="headerlink" title="NIP"></a>NIP</h3><p>NIP最近的发挥太离谱了，只能说他们不晋级的似乎是不可能的事情</p>
<h2 id="关于作业通过的概率"><a href="#关于作业通过的概率" class="headerlink" title="关于作业通过的概率"></a>关于作业通过的概率</h2><p>假如和我一样，在晋级队伍中选择了navi，G2，Faze，Heroic，黑豹，C9，小蜜蜂，<br>那么目前为止，navi已经成功晋级，小蜜蜂，G2和c9目前是1&#x2F;2的状态，G2的实力是很强的，若不是遇到navi状态正好，和自己的失误是不会沦落至此的，晋级的概率大概有60%，黑豹今晚不能晋级的话接下来就比较困难了，暂时算作50%概率晋级，Heroic和Faze还是比较稳的，即使失败，接下来对阵的队伍要么很拉，要么是已经选择的队伍，那么必定会有一支成功晋级，加上bNE 0&#x2F;3拯救无数人，如今仅仅需要3次竞猜成功就能及格，关键就在于今晚的比赛Faze，Heroic，黑豹三支队伍，只要有两只能成功晋级，那么及格就稳了，假如仅一支晋级，那么也有很大概率及格，如果三支队伍都晋级失败，那么就只能听天由命了。<br>希望他们不要辜负bNE给大家的机会</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="Limiter">
      <meta itemprop="description" content="maybe ordinary people don't always crack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1m1t3r's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/hello-world/" class="post-title-link" itemprop="url">welcome!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-16 13:00:03 / 修改时间：17:50:49" itemprop="dateCreated datePublished" datetime="2022-05-16T13:00:03+08:00">2022-05-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="水水水水水"><a href="#水水水水水" class="headerlink" title="水水水水水"></a>水水水水水</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Limiter"
      src="/images/doge.jpg">
  <p class="site-author-name" itemprop="name">Limiter</p>
  <div class="site-description" itemprop="description">maybe ordinary people don't always crack</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Limiter</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

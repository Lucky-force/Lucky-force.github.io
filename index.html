<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="maybe ordinary people don&#39;t always crack">
<meta property="og:type" content="website">
<meta property="og:title" content="L1m1t3r&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="L1m1t3r&#39;s Blog">
<meta property="og:description" content="maybe ordinary people don&#39;t always crack">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Limiter">
<meta property="article:tag" content="ctf,cs,pwn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>L1m1t3r's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">L1m1t3r's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">水水水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/28/%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84libc%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="Limiter">
      <meta itemprop="description" content="maybe ordinary people don't always crack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1m1t3r's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/28/%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84libc%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/" class="post-title-link" itemprop="url">各个版本的libc下载地址</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-28 19:41:04 / 修改时间：19:41:36" itemprop="dateCreated datePublished" datetime="2022-05-28T19:41:04+08:00">2022-05-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://ftp.osuosl.org/pub/ubuntu/pool/main/g/glibc/">http://ftp.osuosl.org/pub/ubuntu/pool/main/g/glibc/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="Limiter">
      <meta itemprop="description" content="maybe ordinary people don't always crack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1m1t3r's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/17/ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ptmalloc源码分析笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-17 12:33:24" itemprop="dateCreated datePublished" datetime="2022-05-17T12:33:24+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 16:52:08" itemprop="dateModified" datetime="2022-05-28T16:52:08+08:00">2022-05-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ptmalloc的设计概述"><a href="#ptmalloc的设计概述" class="headerlink" title="ptmalloc的设计概述"></a>ptmalloc的设计概述</h1><h3 id="ptmalloc内存管理的设计假设"><a href="#ptmalloc内存管理的设计假设" class="headerlink" title="ptmalloc内存管理的设计假设"></a>ptmalloc内存管理的设计假设</h3><p>ptmalloc的设计假设是对于ptmalloc的基本行为概述，可以从宏观层面掌握ptmalloc在内存分配中采取的行为。  </p>
<ol>
<li>具有长周期的大内存分配使用mmap<a href="mmap%E5%92%8Cbrk%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%96%B9%E5%BC%8F%EF%BC%8Cmmap%E6%98%AF%E9%80%9A%E8%BF%87mmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9B%B4%E6%8E%A5%E7%94%B3%E8%AF%B7%E4%B8%80%E5%9D%97%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%80%8Cbrk%E6%98%AF%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%94%B9%E5%8F%98%E5%86%85%E6%A0%B8%E4%B8%ADmm_struct(%E6%8F%8F%E8%BF%B0%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%93%E6%9E%84)%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84brk%E5%80%BC%EF%BC%8C%E6%9D%A5%E6%9B%B4%E6%94%B9heap%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BB%8E%E8%80%8C%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A4%9A%E7%A9%BA%E9%97%B4%E3%80%82%EF%BC%88%E6%AD%A4%E5%A4%96mmap%E5%9C%A8ptmalloc%E4%B8%AD%E6%80%BB%E6%98%AF%E6%98%A0%E5%B0%84%E5%8C%BF%E5%90%8D%E6%95%B0%E6%8D%AE%E6%AE%B5%EF%BC%89">^1</a>。</li>
<li>特别大的内存分配总是使用mmap。</li>
<li>具有短周期的内存分配使用brk。</li>
<li>尽量只缓存临时使用的空闲小内存块，对大内存或者长周期的大内存在释放时都直接还给操作系统。</li>
<li>对空闲的小内存块只会在malloc和free的时候进行合并<a href="%E5%90%88%E5%B9%B6%E6%98%AF%E6%8C%87%E5%AF%B9%E7%89%A9%E7%90%86%E7%9B%B8%E9%82%BB%E7%9A%84chunk%E5%90%88%E5%B9%B6%EF%BC%8C%E5%B9%B6%E9%9D%9E%E6%8C%87%E5%AF%B9bins%E4%B8%AD%E7%9B%B8%E9%82%BB%E7%9A%84chunk%E5%90%88%E5%B9%B6">^1.1</a>,free时空闲内存块可能会放入pool中，不一定返还给操作系统。</li>
<li>收缩堆的条件是当前free的块的大小加上前后能合并的thunk大小大于64kb，并且堆顶的大小达到阈值，才会把堆最顶端的空闲内存返还给操作系统。</li>
<li>多个线程可以从同一个分配区（arena）中分配内存，ptmalloc假设A线程释放一块内存后，线程B会申请类似大小的内存，但是A释放的内存跟B需要的内存并不一定完全相等，可能会有一个小误差，就需要不断对内存块进行切割和合并，这个过程可能会产生内存碎片。</li>
</ol>
<h3 id="内存管理的数据结构"><a href="#内存管理的数据结构" class="headerlink" title="内存管理的数据结构"></a>内存管理的数据结构</h3><h4 id="Main-arena-与-non-main-arena"><a href="#Main-arena-与-non-main-arena" class="headerlink" title="Main_arena 与 non_main_arena"></a>Main_arena 与 non_main_arena</h4><p>每个进程都有一个主分配区和多个非主分配区<a href="%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E9%87%8F%E6%9C%89%E5%85%B3">^2</a>, 非主分配区的出现是为了减少多线程下对分配区的竞争。主分配区能使用mmap和sbrk进行内存管理，非主分配区只能使用mmap。分配区<a href="%E5%88%86%E9%85%8D%E5%8C%BA%E5%B9%B6%E9%9D%9E%E6%8C%87%E8%A6%81%E8%A2%AB%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%87%E8%83%BD%E5%A4%9F%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%89">^3</a>一旦增加就不会再减少。</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>用户请求分配的空间在 ptmalloc 中都使<br>用一个 chunk 来表示。用户调用 free()函数释放掉的内存也并不是立即就归还给操作系统，，它们也会被表示为一个 chunk，ptmalloc 使用特定的数据结构来管理这些空闲的 chunk。chunk的结构如下:<br><img src="/images/images/chunk.PNG" alt="alt chunk"><br>chunk的结构和特性在《glibc内存管理ptmalloc源代码分析》中写的十分详细，此处不再复述。本文主要是对于该文章中源代码分析部分过于简略且难以理解的部分作出补充。</p>
<h3 id="空闲chunk的容器"><a href="#空闲chunk的容器" class="headerlink" title="空闲chunk的容器"></a>空闲chunk的容器</h3><p>ptmalloc使用bins来管理空闲的chunk。（请参考原作部分）</p>
<h3 id="sbrk与mmap"><a href="#sbrk与mmap" class="headerlink" title="sbrk与mmap"></a>sbrk与mmap</h3><p>前文提到过，malloc分配内存时，对于主分配区而言，既能使用mmap来直接映射新内存，也能通过改变brk值来扩展heap。其不同分配方式的条件如下：</p>
<ol>
<li>ptmalloc在开始时，若请求的空间小于 mmap分配阈值（mmap threshold，默认值为 128KB）时，主分配区会调用 sbrk()增加一块大小为 (128 KB + chunk_size) align 4KB 的空间作为 heap。非主分配区会调用 mmap 映射一块大小为HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。</li>
<li>当用户请求内存分配时，首先会在这个空间内找一块合适的 chunk 给用户。当用户释放了 heap 中的 chunk 时，ptmalloc 又会使用 fastbins 和 bins 来组织空闲 chunk。以备用户的下一次分配。</li>
<li>若需要分配的 chunk 大小小于 mmap分配阈值，而 heap 空间又不够，则此时主分配区会通过 sbrk()调用来增加 heap 大小，非主分配区会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到 4KB。</li>
<li>当用户的请求超过 mmap 分配阈值，ptmalloc 会尝试使用 mmap()直接映射一块内存到进程内存空间。使用 mmap()直接映射的 chunk 在释放时直接解除映射，而不再属于进程的内存空间。任何对该内存的访问都会产生段错误。而在heap 中或是 sub-heap 中分配的空间则可能会留在进程内存空间内，还可以再次引用（当然是很危险的）。</li>
<li>当 ptmalloc munmap chunk 时，如果回收的 chunk 空间大小大于 mmap 分配阈值的当前值，并且小于DEFAULT_MMAP_THRESHOLD_MAX（32 位系统默认为 512KB，64 位系统默认为 32MB），ptmalloc 会把 mmap 分配阈值调整为当前回收的 chunk 的大小，并将 mmap 收缩阈值（mmap trim threshold）设置为 mmap 分配阈值的 2 倍。这就是 ptmalloc 的对 mmap分配阈值的动态调整机制，该机制是默认开启的，当然也可以用 mallopt()关闭该机制。</li>
</ol>
<h1 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h1><h3 id="用如下的图来描述malloc的流程："><a href="#用如下的图来描述malloc的流程：" class="headerlink" title="用如下的图来描述malloc的流程："></a>用如下的图来描述malloc的流程：</h3><p><img src="/images/images/malloc.png" alt="alt malloc"></p>
<h3 id="用如下图来描述free的流程："><a href="#用如下图来描述free的流程：" class="headerlink" title="用如下图来描述free的流程："></a>用如下图来描述free的流程：</h3><p><img src="/images/images/free.png" alt="alt free"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ptmalloc同样具有函数mallopt()来配置选项，此处不再细写。</p>
<h1 id="ptmalloc的源代码分析-gt-lt"><a href="#ptmalloc的源代码分析-gt-lt" class="headerlink" title="ptmalloc的源代码分析(&gt;_&lt;)"></a>ptmalloc的源代码分析(&gt;_&lt;)</h1><p>此段用于对《glibc内存管理ptmalloc源代码分析》中的源码部分进行更加详细的注释（原作的代码部分注释过于简略，对很多凭空出现的变量没有指明其作用）。</p>
<h3 id="chunk及其相关宏和数据结构的声明"><a href="#chunk及其相关宏和数据结构的声明" class="headerlink" title="chunk及其相关宏和数据结构的声明"></a>chunk及其相关宏和数据结构的声明</h3><ol>
<li>chunk的声明<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"> INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). </span></span><br><span class="line"><span class="comment">                            前一个chunk的大小（如果前一个chunk是空闲的，否则无意义）*/</span></span><br><span class="line"> INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. </span></span><br><span class="line"><span class="comment">                        大小占多少byte，包括了开销（即除了用户能使用的空间之外用于表示chunk信息的额外空间，chunk具有空间复用，根据chunk是否空闲来具体分析其overhead）*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. </span></span><br><span class="line"><span class="comment">                          双向链表指针，只有chunk空闲的时候有用*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"> <span class="comment">/* Only used for large blocks: pointer to next larger size. </span></span><br><span class="line"><span class="comment"> 只用于large bin中的大块chunk，指向下一个更大的chunk*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. </span></span><br><span class="line"><span class="comment">                                    用于双向链表，只在chunk空闲时有用*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
2.相关转换和检查的宏<br>声明：指向chunk的指针指的是指向chunk头的指针，而指向mem的指针指的是指向用户存储数据的空间的指针（请结合上面那幅chunk的图查看）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back </span></span><br><span class="line"><span class="comment">chunk头指针到用户使用空间指针的来回转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((Void_t*)((char*)(p) + 2*SIZE_SZ)) <span class="comment">/* p代表指向chunk头的指针，这个宏将其转换为用户能使用的空间的指针（就是让p跳过sizeofprev和size）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))<span class="comment">/*mem代表指向用户空间的指针，这个宏将其转换为chunk头的指针*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk </span></span><br><span class="line"><span class="comment">最小的可能chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))<span class="comment">/*offsetof(a, b),求b在a中的偏移，这里fd_nextsize的偏移正好是最小chunk的大小*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk </span></span><br><span class="line"><span class="comment">我们可以分配的最小chunk是一个对齐的极小chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE \</span></span><br><span class="line"><span class="meta"> (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))<span class="comment">/*对min_chunk_size进行了2*SIZE_SZ对齐，不必过于关心*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment </span></span><br><span class="line"><span class="comment">检查m是否对齐*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta"> ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta"> &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"> <span class="comment">/*这里是强制让chunk指针p对齐*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>这几个宏用于将用户请求的分配大小转换成内部需要分配的 chunk 大小，这里需要注意的在转换时不但考虑的地址对齐，还额外加上了 SIZE_SZ，这意味着 ptmalloc 分配内存需要一个额外的overhead，为SIZE_SZ字节，通过chunk的空间复用，我们很容易得出这个overhead为 SIZE_SZ。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment"> padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment"> low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> 检查请求值是否过大以至于在填充和对齐时会发生溢出（原文是零环绕，我觉得溢出更好理解，可能有错&gt;_&lt;）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req) \</span></span><br><span class="line"><span class="meta"> ((unsigned long)(req) &gt;= \</span></span><br><span class="line"><span class="meta"> (unsigned long)(INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version </span></span><br><span class="line"><span class="comment">将请求的内存值转换为应当分配的chunk大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req) \</span></span><br><span class="line"><span class="meta">31</span></span><br><span class="line"> (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \</span><br><span class="line"> MINSIZE : \</span><br><span class="line"> ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same, except also perform argument check </span></span><br><span class="line"><span class="comment">这个宏实际上是将上面两个结合起来，先判断是否超过范围，在根据判断返回应当分配的chunk大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta"> <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123; \</span></span><br><span class="line"><span class="meta"> MALLOC_FAILURE_ACTION; \</span></span><br><span class="line"><span class="meta"> return 0; \</span></span><br><span class="line"><span class="meta"> &#125; \</span></span><br><span class="line"><span class="meta"> (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>chunk 在分割时总是以地址对齐（默认是 8 字节，可以自由设置，但是 8 字节是最小值并且设置的值必须是 2 为底的幂函数值，即是 alignment &#x3D; 2^n，n 为整数且 n&gt;&#x3D;3）的方式来进行的，所以用 chunk-&gt;size 来存储本 chunk 块大小字节数的话，其末 3bit 位总是 0，因此这三位可以用来存储其它信息,以下是对这三位的设置宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use </span></span><br><span class="line"><span class="comment">前一个chunk为使用中，则P位设为1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk </span></span><br><span class="line"><span class="comment">抽取前一个chunk的inuse位（即当前chunk的P位）（p是chunk头指针）（前一个chunk是否空闲是由它下一个chunk的P位决定的）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() </span></span><br><span class="line"><span class="comment">该chunk由mmap分配而来，则M位设为1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk </span></span><br><span class="line"><span class="comment">检查chunk是否由mmap分配*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment"> from a non-main arena. This is only set immediately before handing</span></span><br><span class="line"><span class="comment"> the chunk to the user, if necessary. </span></span><br><span class="line"><span class="comment"> 该chunk属于非主分配区，则A位设为1，如果必要的话，只在将chunk交给用户之前即刻设置*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena </span></span><br><span class="line"><span class="comment">检查chunk是否来自非主分配区*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以下是有关定位chunk的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义SIZE_BITS，用于去掉后三位的影响，返回chunk实际大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits </span></span><br><span class="line"><span class="comment">得到chunk大小，忽略控制信息*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. </span></span><br><span class="line"><span class="comment">返回p指向的chunk物理地址上下一个chunk的指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk </span></span><br><span class="line"><span class="comment">返回p指向的chunk物理地址上上一个chunk的指针（只有在前一个chunk空闲时这个宏才有意义（看代码实现就知道了哦））*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk </span></span><br><span class="line"><span class="comment">返回p+s，将p+s处的空间当作一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用于设置&#x2F;检查&#x2F;清除chunk使用标志位的宏<br>注意：当前chunk的使用标志位储存在下一个chunk里面（P位）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit </span></span><br><span class="line"><span class="comment">抽取p指向chunk的inuse位（当前chunk的inuse位是下一个chunk的P位）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)\</span></span><br><span class="line"><span class="meta">((((mchunkptr)(((char*)(p))+((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing </span></span><br><span class="line"><span class="comment">设置或清除p所指向chunk的inuse位*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>7.设置，检查，清除指定chunk中的inuse位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places </span></span><br><span class="line"><span class="comment">设置，检查，清除指定chunk中的inuse位*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span></span><br><span class="line"><span class="comment">/*就是把p+s指向的空间当作一个chunk，然后把设置P位（感觉有点怪，明明设置的是P位，却叫inuse位设置宏）*/</span></span><br></pre></td></tr></table></figure>
<p>8.设置chunk的size的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit </span></span><br><span class="line"><span class="comment">直接设置chunk（由p指向）的szie域为s，并保留原来的控制信息*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s) ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field </span></span><br><span class="line"><span class="comment">直接设置chunk的size域为s*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) </span></span><br><span class="line"><span class="comment">将foot的值设置为s*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s) (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：前面有所提到，foot就是下一个chunk保存其物理相邻的上一个空闲chunk大小的位置，由于s正是要设置的chunk大小，所以set_foot宏用p+s定位到下一个chunk的prev_size域。</p>
<h3 id="bins及其相关源码解析"><a href="#bins及其相关源码解析" class="headerlink" title="bins及其相关源码解析"></a>bins及其相关源码解析</h3><h4 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h4><p>Small bins在bins的数组（其实不准确，以下会有说明）中从下标2开始，一直到下标65，一共有64个，但一般实际用到的只有62个（最后两个不用）。每个Small bin是一个链表头，包括malloc_chunk* fd 和 malloc_chunk* bk两个指针。注意，由于源码中拥有上述两个指针的是malloc_chunk结构体，在编写代码的时候，一个指向malloc_chunk结构体的指针可以直接引用其中的元素，但如果每个bin都定义为一个malloc_chunk,其mem，size，prev_size空间都没有用，实际上就浪费了，因此直接定义一个256大小的指针数组（bin有128个），每个元素是malloc_chunk* 指针，用两个元素代表一个bin（fd和bk），但是又用一个malloc_chunk指针p指向bin向前偏移2个SIZE_SZ的位置（或者说指向该bin的上一个bin），这样就可以用p-&gt;fd和p-&gt;bk来直接引用这两个指针，更为方便和易读，如下图<br><img src="/images/images/bins.png" alt="alt bins"></p>
</li>
</ol>
<p>注意：以下的下标（index）都是表示bin的下标而非数组元素的下标<br>ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index有如下关系：</p>
<p>Chunk_size&#x3D;2 * SIZE_SZ * index（SIZE_SZ可看作当前系统指针的大小，反正数值一样）</p>
<p>ptmalloc 维护了 62 个双向环形链表（每个链表都具有链表头节点，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲 chunk 的大小一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可以用如下图来表示在 SIZE_SZ 为 4B 的平台上 ptmalloc 对 512B 字节以下的空闲 chunk 组织方式（所谓的分箱机制）<br><img src="/images/images/small_bins.png" alt="alt small_bins"></p>
<h4 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h4><p>在 SIZE_SZ 为 4B 的平台上，大于等于 512B 的空闲 chunk，或者，在 SIZE_SZ 为 8B 的平台上，大小大于等于 1024B 的空闲 chunk，由 sorted bins 管理。Large bins 一共包括 63 个 bin，每个 bin 中的 chunk 大小不是一个固定公差的等差数列，而是分成 6 组 bin，每组 bin 是一个固定公差的等差数列，每组的 bin 数量依次为 32、16、8、4、2、1，公差依次为 64B、512B、4096B、32768B、262144B 等.<br>以 SIZE_SZ 为 4B 的平台为例，第一个 large bin 的起始 chunk 大小为 512B，共 32 个 bin，公差为 64B，等差数列满足如下关系：Chunk_size&#x3D;512 + 64 * index<br>第二个 large bin 的起始 chunk 大小为第一组 bin 的结束 chunk 大小，满足如下关系：<br>Chunk_size&#x3D;512 + 64 * 32 + 512 * index<br>同理，我们可计算出每个 bin 的起始 chunk 大小和结束 chunk 大小。这些 bin 都是很有规律的，其实 small bins 也是满足类似规律，small bins 可以看着是公差为 8 的等差数列，一共有 64 个 bin（第 0 和 1bin 不存在），所以我们可以将 small bins 和 large bins 存放在同一个包含 128 个 chunk 的数组上，数组的前一部分位 small bins，后一部分为 large bins，每个 bin的 index 为 chunk 数组的下标，于是，我们可以根据数组下标计算出该 bin 的 chunk 大小（smallbins）或是 chunk 大小范围（large bins），也可以根据需要分配内存块大小计算出所需 chunk所属 bin 的 index，ptmalloc 使用了一组宏巧妙的实现了这种计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128  <span class="comment">/*定义了bin的数量*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64 <span class="comment">/*定义了small_bin的数量*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT <span class="comment">/*malloc_alignment 定义为 2*SIZE_SZ,是用来处理chunk地址对齐的宏*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE (NSMALLBINS * SMALLBIN_WIDTH) <span class="comment">/*定义最小的Large chunk大小*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta"> ((unsigned long)(sz) <span class="string">&lt; (unsigned long)MIN_LARGE_SIZE) /*这个宏用于判断sz（p-&gt;</span>size）的大小是否属于small chunk的范围*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta"> (SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) &gt;&gt; 4) : (((unsigned)(sz)) &gt;&gt; 3))<span class="comment">/*通过chunk的大小返回其在small bins中的index（从2开始）*/</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*以下分别是32位和64位下根据size大小返回其在Large bins 中index（从66开始）的宏*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 38)? 56 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20)? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta"> 126)</span></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48)? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">36</span></span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)? <span class="number">91</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)? <span class="number">110</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)? <span class="number">119</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>): \</span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)? <span class="number">124</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>): \</span><br><span class="line"> <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta"> (SIZE_SZ == 8 ? largebin_index_64 (sz) : largebin_index_32 (sz))<span class="comment">/*这个宏是把上面的两个结合起来，直接通过size返回在large bins中的index（无关操作系统位数）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))<span class="comment">/*这个是上面宏的最后缝合体，直接通过size返回bins中的index*/</span></span></span><br></pre></td></tr></table></figure>

<h4 id="几个对bins的操作宏"><a href="#几个对bins的操作宏" class="headerlink" title="几个对bins的操作宏"></a>几个对bins的操作宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mbinptr</span>;</span><span class="comment">/*后面的源代码常用这里的定义，建议记住</span></span><br><span class="line"><span class="comment">是malloc_bin_pointer的简写，前面讲过了bin的访问方式*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist </span></span><br><span class="line"><span class="comment">通过index返回bin的地址，注意，bin_at(0)不存在*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \<span class="comment">/*m是malloc_state结构体指针，后面会讲，这里面放着bins数组，i就是传入的index*/</span></span></span><br><span class="line"> (mbinptr) (((<span class="type">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>])) \</span><br><span class="line"> - offsetof (<span class="keyword">struct</span> malloc_chunk, fd))<span class="comment">/*这个offsetof前面也有讲过，这段代码仔细看看就理解了*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回b指向bin的下一个bin的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char*)(b) + (sizeof(mchunkptr)&lt;&lt;1)))<span class="comment">/*sizeof（mchunkptr）&lt;&lt;1其实就是8&lt;&lt;1 == 16,正好是两个bin之间的距离*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins </span></span><br><span class="line"><span class="comment">bin中的第一个chunk和最后一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)<span class="comment">/*bin维护的是双向链表哦*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list </span></span><br><span class="line"><span class="comment">将一个chunk从bin维护的双向链表中摘下*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; \<span class="comment">/*这里传BK和FD就是为了让你传个载体，毕竟宏里面不好定义新变量*/</span></span></span><br><span class="line"> FD = P-&gt;fd; \</span><br><span class="line"> BK = P-&gt;bk; \</span><br><span class="line"> <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) \<span class="comment">/*这个宏直接返回第一个参数（迷），这里就是判断传入的p所指向的chunk是否真的在双向链表中*/</span></span><br><span class="line"> malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); \<span class="comment">/*打印错误信息*/</span></span><br><span class="line"> <span class="keyword">else</span> &#123; \</span><br><span class="line"> FD-&gt;bk = BK; \</span><br><span class="line"> BK-&gt;fd = FD; \<span class="comment">/*将chunk取出*/</span></span><br><span class="line"> <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) \</span><br><span class="line"> &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123; \<span class="comment">/*若P所指向的chunk不在small bin中且该chunk有fd_nextsize指针（说明是large chunk）*/</span></span><br><span class="line"> <span class="comment">/*以下是当为large chunk时，还需要做的操作（从横向循环链表中删除）*/</span></span><br><span class="line"> assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); \</span><br><span class="line"> assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); \</span><br><span class="line"> <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123; \</span><br><span class="line"> <span class="keyword">if</span> (P-&gt;fd_nextsize == P) \</span><br><span class="line"> FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \</span><br><span class="line"> <span class="keyword">else</span> &#123; \</span><br><span class="line"> FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span><br><span class="line"> FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span><br><span class="line"> P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \</span><br><span class="line"> P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line"> P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span><br><span class="line"> P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; \</span><br><span class="line"> &#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h4><p>Unsorted bin 可以看作是 small bins 和 large bins 的 cache，只有一个 unsorted bin，以双向链表管理空闲 chunk，空闲 chunk 不排序，所有的 chunk 在回收时都要先放到 unsorted bin中，分配时，如果在 unsorted bin 中没有合适的 chunk，就会把 unsorted bin 中的所有 chunk分别加入到所属的 bin 中，然后再在 bin 中分配合适的 chunk。Bins 数组中的元素 bin[1]（bins数组下标是1到128哦）用于存储 unsorted bin 的 chunk 链表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1)) <span class="comment">/*用于获得unsorted bin的地址，M是malloc_state结构体指针*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))<span class="comment">/*初始化top chunk的宏，这里暂时把top chunk当作unsorted chunk来初始化，写的很迷惑，不知道干什么的*/</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h4><p>Fast bins 主要是用于提高小内存的分配效率，默认情况下，对于 SIZE_SZ 为 4B 的平台，小于 64B 的 chunk 分配请求，对于 SIZE_SZ 为 8B 的平台，小于 128B 的 chunk 分配请求，首先会查找 fast bins 中是否有所需大小的 chunk 存在（精确匹配），如果存在，就直接返回。<br>Fast bins 可以看着是 LIFO 的栈，使用单向链表实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mfastbinptr</span>;</span><span class="comment">/*指向fast bin的指针也和其他指向bin的指针一样定义为malloc chunk指针，便于访问fd和bk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])<span class="comment">/*ar_ptr是指向malloc_state结构体的指针，fastbinsY是储存fast bin的数组，也定义在malloc_state中，与bins数组分开定义</span></span></span><br><span class="line"><span class="comment"><span class="meta">这个宏的作用是通过idex返回fast bin的地址*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta"> ((((unsigned int)(sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"> <span class="comment">/*这个宏是根据chunk size大小返回其对应的fast bin index*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support </span></span><br><span class="line"><span class="comment">fast bin所支持的最大请求值大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE))+1)<span class="comment">/*这里先将请求值转换为实际chunk大小值，再通过chunk大小转换为index，index加1即为bin的数量（10个）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br><span class="line"><span class="comment">/*FASTBIN_CONSOLIDATION_THRESHOLD 为 64k，当每次释放的 chunk 与该chunk 相邻的空闲 chunk 合并后的大小大于 64k </span></span><br><span class="line"><span class="comment">时，就认为内存碎片可能比较多了，就需要把 fast bins 中的所有 chunk 都进行合并，以减少内存碎片对系统的影响。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*定义了默认的fast bin中最大chunk大小，因此fast bins通常只使用了前7个（0~6）*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta"> global_max_fast = (((s) == 0) \</span></span><br><span class="line"><span class="meta"> ? SMALLBIN_WIDTH: ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"> <span class="comment">/*SMALLBIN_WIDTH定义为MALLOC_ALIGN_MASK == 2*SIZE_SZ</span></span><br><span class="line"><span class="comment"> ptmalloc默认情况下调用 set_max_fast(s)将全局变量 global_max_fast 设置为 DEFAULT_MXFAST*/</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"> <span class="comment">/*get_max_fast()用于获得这个全局变量 global_max_fast的值。*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="核心结构体分析"><a href="#核心结构体分析" class="headerlink" title="核心结构体分析"></a>核心结构体分析</h3><p>每个分配区是 struct malloc_state 的一个实例，ptmalloc 使用 malloc_state 来管理分配区，而参数管理使用 struct malloc_par，全局拥有一个唯一的 malloc_par 实例。</p>
<h4 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h4><p>1.malloc_state定义<br>malloc_state 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line"> <span class="comment">/* Serialize access. </span></span><br><span class="line"><span class="comment"> 用于串行访问的锁*/</span></span><br><span class="line"> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Flags (formerly in max_fast). </span></span><br><span class="line"><span class="comment"> 标志位*/</span></span><br><span class="line"> <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line"> <span class="comment">/* Statistics for locking. Only used if THREAD_STATS is defined. </span></span><br><span class="line"><span class="comment"> 用于对锁的统计变量，仅在THREAD_STATS定义时使用，默认没有定义 THREAD_STATS，所以不会对锁的争用情况做统计。*/</span></span><br><span class="line"> <span class="type">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Fastbins </span></span><br><span class="line"><span class="comment"> fastbinsY 拥有 10（NFASTBINS）个元素的数组，用于存放每个 fast chunk 链表头指针，所以 fast bins 最多包含 10 个 fast chunk 的单向链表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin </span></span><br><span class="line"><span class="comment"> top chunk的基址*/</span></span><br><span class="line"> mchunkptr top;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* The remainder from the most recent split of a small request </span></span><br><span class="line"><span class="comment"> 定义了last remainder的指针</span></span><br><span class="line"><span class="comment"> 分配区上次分配 small chunk 时，从一个 chunk 中分裂出一个 small chunk 返回给用户，分裂后的剩余部分形成一个 chunk，last_remainder 就是指向的这个 chunk。*/</span></span><br><span class="line"> mchunkptr last_remainder;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Normal bins packed as described above </span></span><br><span class="line"><span class="comment"> 普通的bin数组（除了fast bins以外的bin都在这里面）*/</span></span><br><span class="line"> mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Bitmap of bins </span></span><br><span class="line"><span class="comment"> bins的bitmap，下面会详细解释的*/</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Linked list </span></span><br><span class="line"><span class="comment"> 由于每个分配区都有一个malloc_state结构体，用以下的指针将它们连起来*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD<span class="comment">/*这个宏查不到，后面版本的libc不再有PER_THREAD的判断，直接定义了以下变量*/</span></span></span><br><span class="line"> <span class="comment">/* Linked list for free arenas. </span></span><br><span class="line"><span class="comment"> 这个是多线程时，用于连接空闲分配区的指针*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Memory allocated from the system in this arena. </span></span><br><span class="line"><span class="comment"> 这个分配区管理的从系统获得的内存空间*/</span></span><br><span class="line"> INTERNAL_SIZE_T system_mem;</span><br><span class="line"> INTERNAL_SIZE_T max_system_mem;</span><br><span class="line"><span class="comment">/*前面定义过 #define INTERNAL_SIZE_T size_t，size_t是系统指针长度</span></span><br><span class="line"><span class="comment">system_mem是当前分配区已经分配的内存大小，max_system_mem是当前分配区最大能分配的内存大小*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>THREAD_STATS应该是在多分配区时定义的宏（翻宏定义发现其在arena.c中首次定义）</p>
<p>2.用于设置flag中fast chunk的标志位bit0的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U) <span class="comment">/*首先将FASTCHUNKS_BIT定义为1，用于作掩码（大概）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="comment">/*检查是否有fast chunks，M是指向malloc_state结构体的指针，其中flag的bit0位为1，则没有fast chunk，为0，则有*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS<span class="comment">/*当这个宏定义的时候，将clear_fastchunks 和 set_fastchunks 定义为下*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将flag的bit0位置1，表示不再有fast chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="comment">/*catomic是原子操作，后面跟的是操作方式，如catomic_or(a,b) 表示 a = a | b</span></span><br><span class="line"><span class="comment">注意，这里的M又表示malloc_state结构体，而非其指针（写的真的迷）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将flag的bit0位置0，表示有fast chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">/*当ATOMIC_FASTBINS宏没有定义的时候，将clear_fastchunks 和 set_fastchunks 定义为下*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里就直接用逻辑操作来更改flag的bit0了*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) ((M)-&gt;flags |= FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) ((M)-&gt;flags &amp;= ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*暂时不必关心这样分开定义的原因（我也不知道），只需要知道这两个宏的作用即可*/</span></span><br></pre></td></tr></table></figure>
<p>注意：刚初始化完成后的 malloc_state 实例中，flags值为 0，表示该分配区中有 fast chunk，但实际上没有，试图从 fast bins 中分配 chunk 都会返回 NULL，在第一次调用函数 malloc_consolidate()对 fast bins 进行 chunk 合并时，如果 max_fast大于 0，会调用 clear_fastchunks 宏，标志该分配区中已经没有 fast chunk，因为函数malloc_consolidate()会合并所有的 fast bins 中的 chunk。clear_fastchunks 宏只会在函数malloc_consolidate()中调用。当有 fast chunk 加入 fast bins 时，就是调用 set_fastchunks 宏标识分配区的 fast bins 中存在 fast chunk。</p>
<p>3.用于设置flag中的bit1，是MORCORE的标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)<span class="comment">/*将NONCONTIGUOUS_BIT定义为2，也是当掩码*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断bit1是否为0，若为0，表示MORCORE返回连续的虚拟地址空间，为1则不连续*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断bit1是否为1（!=0）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面两个宏也是对bit1 的设置宏*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br></pre></td></tr></table></figure>
<p>对于主分配区，MORECORE 其实为 sbr()，默认返回连续虚拟地址空间，对于非主分配区，使用 mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为，而默认情况下 mmap 映射区域是不保证虚拟地址空间连续的，所以非住分配区默认分配非连续虚拟地址空间。</p>
<p>4.binmap概述及其相关宏<br>binmap 字段是一个 int 数组，ptmalloc 用一个 bit 来标识该 bit 对应的 bin 中是否包含空闲 chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这两个宏一起定义了BITSPERMAP，用于BINMAPSIZE宏的定义，</span></span><br><span class="line"><span class="comment">但我不知道为什么要分开定义，或许是为了扩展性*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*binmap数组的大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP) <span class="comment">/*看来就是NBINS / 32（因为每个block可以储存32个bit）*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将bin的index转换为binmap中的block（块）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)<span class="comment">/*binmap数组中每个binmap代表一个块，每个bit位代表一个bin，</span></span></span><br><span class="line"><span class="comment"><span class="meta">bin的index从整个数组的低位到高位依次对应</span></span></span><br><span class="line"><span class="comment"><span class="meta">通过block和bit组合来确定一个bin，</span></span></span><br><span class="line"><span class="comment"><span class="meta">如bin[1]对应block[0]的bit1位</span></span></span><br><span class="line"><span class="comment"><span class="meta">bin[80]对应block[2]的bit16位*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将bin的index转换为binmap中的bit位*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT)-1))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面的宏分别是标记binmap对应bit为1，标记为0，检查binmap对应bit的值</span></span><br><span class="line"><span class="comment">便于快速得知对应bin中是否有chunk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m,i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span></span><br></pre></td></tr></table></figure>
<h4 id="Malloc-par"><a href="#Malloc-par" class="headerlink" title="Malloc_par"></a>Malloc_par</h4><p>1.Malloc_par 的定义<br>Malloc_par是全局唯一的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> &#123;</span></span><br><span class="line"> <span class="comment">/* Tunable parameters */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;<span class="comment">/*收缩阈值，默认为128KB，可通过；mallopt()函数设置*/</span></span><br><span class="line"> INTERNAL_SIZE_T top_pad;<span class="comment">/*top_pad是在内存分配时额外分配的内存*/</span></span><br><span class="line"> INTERNAL_SIZE_T mmap_threshold;<span class="comment">/*mmap分配阈值，默认为128KB（会自己动态修改，查看前文的描述）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD <span class="comment">/*后面版本的libc不再有PER_THREAD的判断，直接定义了以下变量，用于限制分配区的数量*/</span></span></span><br><span class="line"> INTERNAL_SIZE_T arena_test;</span><br><span class="line"> INTERNAL_SIZE_T arena_max;</span><br><span class="line"><span class="comment">/*在 32 位系统上 arena_test 默认值为 2，64 位系统上的默认值为 8，当每个进程的分配区数量小于等于 arena_test 时，</span></span><br><span class="line"><span class="comment">不会重用已有的分配区。为了限制分配区的总数，用 arena_max 来保存分配区的最大数量，当系统中的分配区数量达到 arena_max，</span></span><br><span class="line"><span class="comment">就不会再创建新的分配区，只会重用已有的分配区。这两个字段都可以使用 mallopt()函数设置。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="comment">/* Memory map support */</span></span><br><span class="line"> <span class="type">int</span> n_mmaps;<span class="comment">/*当前进程使用mmap分配的内存块个数*/</span></span><br><span class="line"> <span class="type">int</span> n_mmaps_max;<span class="comment">/*mmap可分配的内存块最大数量（默认为65536，可用mallopt函数修改）*/</span></span><br><span class="line"> <span class="type">int</span> max_n_mmaps;<span class="comment">/*当前进程使用 mmap()函数分配的内存块的数量的最大值，有关系 n_mmaps &lt;= max_n_mmaps 成立。这个字段</span></span><br><span class="line"><span class="comment"> 是由于 mstats()函数输出统计需要这个字段。（迷）*/</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment"> it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment"> dynamic behavior. </span></span><br><span class="line"><span class="comment"> 表示是否开启mmap分配阈值动态调整，默认为0，表示开启*/</span></span><br><span class="line"> <span class="type">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Cache malloc_getpagesize </span></span><br><span class="line"><span class="comment"> 表示系统页的大小，默认为4KB*/</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> pagesize;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Statistics */</span></span><br><span class="line"> <span class="comment">/*mmapped_mem 和 max_mmapped_mem 都用于统计 mmap 分配的内存大小，一般情况下两个字段的值相等，max_mmapped_mem 用于 mstats()函数。*/</span></span><br><span class="line"> INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line"> INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line"></span><br><span class="line"> INTERNAL_SIZE_T max_total_mem; <span class="comment">/* only kept for NO_THREADS 在单线程情况下用于统计进程分配的内存总数。*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* First address handed out by MORECORE/sbrk. </span></span><br><span class="line"><span class="comment"> 堆的起始地址*/</span></span><br><span class="line"> <span class="type">char</span>* sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配区的初始化"><a href="#分配区的初始化" class="headerlink" title="分配区的初始化"></a>分配区的初始化</h3><ol>
<li><p>相关全局变量<br>Ptmalloc 定义了如下几个全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span>;</span><span class="comment">/*主分配区只有这一个，但非主分配区在需要时可以继续定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is only one instance of the malloc parameters. </span></span><br><span class="line"><span class="comment">mp_是全局唯一一个malloc_par 实例，用于管理参数和统计信息*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum size of memory handled in fastbins. </span></span><br><span class="line"><span class="comment">fast bins 中最大的chunk大小*/</span></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主分配区main_arena初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(av)</span> mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*写的很迷，但大体就是定义一个初始化函数，形参为malloc_state* av*/</span></span></span><br><span class="line"><span class="comment">/*分析下列函数可知av是malloc_state指针，可原文写的是av是malloc_state实例,emmmm*/</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> mbinptr bin;</span><br><span class="line"> <span class="comment">/* Establish circular links for normal bins </span></span><br><span class="line"><span class="comment"> 先初始化bins，由于bin都为空，所以将各自的fd和bk都指向自己*/</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line"> bin = bin_at(av,i);</span><br><span class="line"> bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line"> <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*写的什么鬼，没看懂*/</span></span></span><br><span class="line"></span><br><span class="line"> set_noncontiguous(av);</span><br><span class="line"> <span class="keyword">if</span> (av == &amp;main_arena)<span class="comment">/*如果是主分配区，设置fast chunk最大值global_max_fast*/</span></span><br><span class="line"> set_max_fast(DEFAULT_MXFAST);</span><br><span class="line"></span><br><span class="line"> av-&gt;flags |= FASTCHUNKS_BIT;<span class="comment">/*设置flag的bit0*/</span></span><br><span class="line"> av-&gt;top = initial_top(av);<span class="comment">/*初始化top chunk，此时的top chunk指针指向</span></span><br><span class="line"><span class="comment"> unsorted chunk（看前面的initial_top定义）*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>ptmalloc参数初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set up basic state so that _int_malloc et al can work. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init_minimal</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEFAULT_TOP_PAD != 0</span></span><br><span class="line"> mp_.top_pad = DEFAULT_TOP_PAD;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> mp_.n_mmaps_max = DEFAULT_MMAP_MAX;</span><br><span class="line"> mp_.mmap_threshold = DEFAULT_MMAP_THRESHOLD;</span><br><span class="line"> mp_.trim_threshold = DEFAULT_TRIM_THRESHOLD;</span><br><span class="line"> mp_.pagesize = malloc_getpagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line"> mp_.arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>);</span><br><span class="line"> narenas = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是将全局变量 mp_的字段初始化为默认值,会根据系统 cpu 的个数设置 arena_test 的值，默认 32 位系统是双核，64 位系统为 8 核，arena_test 也就设置为相应的值。</p>
</li>
<li><p>配置选项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mALLOPt</span><span class="params">(<span class="type">int</span> param_number, <span class="type">int</span> value)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mALLOPt</span><span class="params">(param_number, value)</span> <span class="type">int</span> param_number; <span class="type">int</span> value;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line"> mstate av = &amp;main_arena;</span><br><span class="line"> <span class="type">int</span> res = <span class="number">1</span>;<span class="comment">/*定义返回值为1，若配置失败，res会变成0*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*检查主分配区是否初始化，没有则调用ptmalloc_init初始化ptmalloc</span></span><br><span class="line"><span class="comment"> （注意，这里并没有直接初始化主分配区哦）*/</span></span><br><span class="line"> <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">0</span>)</span><br><span class="line"> ptmalloc_init ();</span><br><span class="line"></span><br><span class="line"> (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);<span class="comment">/*获取主分配区的锁*/</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Ensure initialization/consolidation </span></span><br><span class="line"><span class="comment"> 确保初始化，调用malloc_consolidate()函数，malloc_consolidate()函数会判断主分配</span></span><br><span class="line"><span class="comment"> 区是否已经初始化，如果没有，则初始化主分配区。*/</span></span><br><span class="line"> malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下是配置选项*/</span></span><br><span class="line"> <span class="keyword">switch</span>(param_number) &#123;</span><br><span class="line"> <span class="keyword">case</span> M_MXFAST:<span class="comment">/*修改MAX_FAST_SIZE值为value*/</span></span><br><span class="line"> <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123;</span><br><span class="line"> set_max_fast(value);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> res = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_TRIM_THRESHOLD:<span class="comment">/*修改trim_threshold（收缩阈值）值为value,</span></span><br><span class="line"><span class="comment"> no_dyn_threshold为1（关闭动态阈值调整）*/</span></span><br><span class="line"> mp_.trim_threshold = value;</span><br><span class="line"> mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_TOP_PAD:<span class="comment">/*将top_pad设为value,no_dyn_threshold为1（关闭动态阈值调整）*/</span></span><br><span class="line"> mp_.top_pad = value;</span><br><span class="line"> mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_MMAP_THRESHOLD:<span class="comment">/*设置mmap分配阈值*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_ARENAS</span></span><br><span class="line"> <span class="comment">/* Forbid setting the threshold too high. </span></span><br><span class="line"><span class="comment"> 禁止将mmap_threshold设置的过高*/</span></span><br><span class="line"> <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)value &gt; HEAP_MAX_SIZE/<span class="number">2</span>)</span><br><span class="line"> res = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> mp_.mmap_threshold = value;</span><br><span class="line"> mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_MMAP_MAX:<span class="comment">/*改变当前mmap分配内存块个数为value*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_MMAP</span></span><br><span class="line"> <span class="keyword">if</span> (value != <span class="number">0</span>)</span><br><span class="line"> res = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> mp_.n_mmaps_max = value;</span><br><span class="line"> mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_CHECK_ACTION:<span class="comment">/*设置检查行为*/</span></span><br><span class="line"> check_action = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_PERTURB:<span class="comment">/*不知道*/</span></span><br><span class="line"> perturb_byte = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="comment">/*定义了PER_THREAD时，可以设置这两个限制非主分配区的变量*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"> <span class="keyword">case</span> M_ARENA_TEST:</span><br><span class="line"> <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line"> mp_.arena_test = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> M_ARENA_MAX:</span><br><span class="line"> <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line"> mp_.arena_max = value;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> &#125;</span><br><span class="line"> (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<span class="comment">/*设置完成，解除主分配区的锁*/</span></span><br><span class="line"> <span class="keyword">return</span> res;<span class="comment">/*返回设置是否成功*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：mp_都没有锁，对 mp_中参数字段的修改，是通过主分配区的锁来同步的。</p>
</li>
<li><p>Ptmalloc 的初始化<br>Ptmalloc 的初始化发生在进程的第一个内存分配请求，当 ptmalloc 的初始化一般都在用<br>户的第一次调用 malloc()或 remalloc()之前，因为操作系统和 Glibc 库为进程的初始化做了不少工作，在用户分配内存以前，Glibc 已经分配了多次内存。<br>在 ptmalloc 中 malloc()函数的实际接口函数为 public_mALLOc()，这个函数最开始会执行如下的一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, __const <span class="type">__malloc_ptr_t</span>)<span class="comment">/*声明hook函数指针，从后面代码可看出，这个指针暂时拿来作为_malloc_hook_ini函数指针了*/</span></span><br><span class="line">= force_reg (__malloc_hook);<span class="comment">/*将hook函数指针赋值为__malloc_hook*/</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">/*前面写过，这个宏直接返回第一个参数，这里就相当于hook != NULL*/</span></span><br><span class="line"><span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));<span class="comment">/*执行hook函数*/</span></span><br></pre></td></tr></table></figure>
<p>在定义了__malloc_hook()全局函数的情况下，只是执行__malloc_hook()函数，在进程初始化时__malloc_hook 指向的函数为 malloc_hook_ini()（暂时的，会先赋值一份给hook，在执行malloc_hook_ini函数后会变成NULL）。注意，这里写的只是开始的一小部分代码，后面还有一堆代码，只是暂时没有写出来，可不要以为public_mALLOc函数就这点哦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*进程初始化的部分代码，声明__malloc_hook函数指针，并指向malloc_hook_ini*/</span></span><br><span class="line"><span class="type">_malloc_ptr_t</span> <span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line"><span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">__malloc_ptr_t</span>)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure>
<p>malloc_hook_ini()的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Void_t*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">malloc_hook_ini(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">__malloc_ptr_t</span> caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">malloc_hook_ini(sz, caller)</span><br><span class="line"><span class="type">size_t</span> sz; <span class="type">const</span> <span class="type">__malloc_ptr_t</span> caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*emmmm,就是不同情况下的声明方式，下面是函数的实现*/</span></span><br><span class="line">&#123;</span><br><span class="line">__malloc_hook = <span class="literal">NULL</span>;<span class="comment">/*将__malloc_hook设为NULL，原来是指向malloc_hook_ini，</span></span><br><span class="line"><span class="comment">注意hook这个函数指针并没有变哦*/</span></span><br><span class="line">ptmalloc_init();<span class="comment">/*调用ptmalloc初始化函数*/</span></span><br><span class="line"><span class="keyword">return</span> public_mALLOc(sz);<span class="comment">/*调用public_mALLOc函数（malloc的实际接口函数）*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ptmalloc_init()函数在初始化 ptmalloc 完成后，将全局变量__malloc_initialized 设置为 1，当 pbulit_mALLOc()函数再次执行时，先执行malloc_hook_ini()函数，malloc_hook_ini()函数调用 ptmalloc_init()，ptmalloc_init()函数首先判断__malloc_initialized 是否为 1，如果是，则退出 ptmalloc_init()，不再执行 ptmalloc 初始化。</p>
</li>
</ol>
<h3 id="Ptmalloc-未初始化时分配-x2F-释放内存"><a href="#Ptmalloc-未初始化时分配-x2F-释放内存" class="headerlink" title="Ptmalloc 未初始化时分配&#x2F;释放内存"></a>Ptmalloc 未初始化时分配&#x2F;释放内存</h3><p>当 ptmalloc 的初始化函数 ptmalloc_init()还没有调用之前（也就是还没有初始化ptmalloc之前），Glibc 中可能需要分配内存，比如线程私有实例的初始化需要分配内存，为了解决这一问题，ptmalloc 封装了内部的分配释放函数供在这种情况下使用。Ptmalloc 提供了三个函数，malloc_starter()，memalign_starter()，free_starter()，但没有提供 realloc_starter()函数。这几个函数的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*分配一块sz大小的内存*/</span></span><br><span class="line"><span class="type">static</span> Void_t*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">malloc_starter(<span class="type">size_t</span> sz, <span class="type">const</span> Void_t *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">malloc_starter(sz, caller) <span class="type">size_t</span> sz; <span class="type">const</span> Void_t *caller;<span class="comment">/*这个是回调函数的指针么，不知道有什么用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">Void_t* victim;<span class="comment">/*先定义一个指针，之后将其指向分配的内存*/</span></span><br><span class="line">victim = _int_malloc(&amp;main_arena, sz);<span class="comment">/*_int_malloc是ptmalloc内部函数实现，后面会详讲，只需知道是通过主分配区分配一块zs大小内存，并返回其指针。*/</span></span><br><span class="line"><span class="keyword">return</span> victim ? BOUNDED_N(victim, sz) : <span class="number">0</span>;<span class="comment">/*成功则返回指针victim，失败则返回0*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*分配一块sz大小的内存，并按align对齐*/</span></span><br><span class="line"><span class="type">static</span> Void_t*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">memalign_starter(<span class="type">size_t</span> align, <span class="type">size_t</span> sz, <span class="type">const</span> Void_t *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">memalign_starter(align, sz, caller) <span class="type">size_t</span> align, sz; <span class="type">const</span> Void_t *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">Void_t* victim;</span><br><span class="line">victim = _int_memalign(&amp;main_arena, align, sz);</span><br><span class="line"><span class="keyword">return</span> victim ? BOUNDED_N(victim, sz) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将mem指向的内存free掉*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">free_starter(Void_t* mem, <span class="type">const</span> Void_t *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">free_starter(mem, caller) Void_t* mem; <span class="type">const</span> Void_t *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">mchunkptr p;</span><br><span class="line"><span class="keyword">if</span>(!mem) <span class="keyword">return</span>;</span><br><span class="line">p = mem2chunk(mem);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">munmap_chunk(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">_int_free(&amp;main_arena, p, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_int_free(&amp;main_arena, p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述三个函数是在未初始化ptmalloc时使用的，分别对应_int_malloc,_int_memalign,_int_free</p>
<h3 id="ptmalloc-init-函数"><a href="#ptmalloc-init-函数" class="headerlink" title="ptmalloc_init()函数"></a>ptmalloc_init()函数</h3><p>该函数较长，顺序分段解析</p>
<ol>
<li><p>检查全局变量__malloc_initialized</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s;<span class="comment">/*用于环境变量读取时临时存储一些字符*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">char</span>* s;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*这里只是不同情况下的s的定义*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> secure = <span class="number">0</span>;<span class="comment">/*暂时不知道作用，看后面*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__malloc_initialized &gt;= <span class="number">0</span>) <span class="comment">/*如果全局变量__malloc_initialized == 0,表示正在初始化，&gt; 0, 表示初始化完成，两种情况下直接退出*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">__malloc_initialized = <span class="number">0</span><span class="comment">/*设置为0，表示正在初始化，防止冲突*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为多线程版本的 ptmalloc 的 pthread 初始化做准备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined SHARED &amp;&amp; !USE___THREAD</span></span><br><span class="line"><span class="comment">/* ptmalloc_init_minimal may already have been called via__libc_malloc_pthread_startup, above. */</span></span><br><span class="line"><span class="keyword">if</span> (mp_.pagesize == <span class="number">0</span>)</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">ptmalloc_init_minimal();</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_THREADS</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC</span></span><br><span class="line"><span class="comment">/* We know __pthread_initialize_minimal has already been called,and that is enough. </span></span><br><span class="line"><span class="comment">定义了_LIBC，则说明_pthread_initialize_minimal函数已经被调用过了*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> NO_STARTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_STARTER</span></span><br><span class="line"><span class="comment">/* With some threads implementations, creating thread-specific data</span></span><br><span class="line"><span class="comment">or initializing a mutex may call malloc() itself. Provide a</span></span><br><span class="line"><span class="comment">simple starter version (realloc() won‘t work). </span></span><br><span class="line"><span class="comment">ptmalloc 未初始化时，不能使用 remalloc 函数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下暂时将对应的hook函数保存起来*/</span></span><br><span class="line">save_malloc_hook = __malloc_hook;</span><br><span class="line">save_memalign_hook = __memalign_hook;</span><br><span class="line">save_free_hook = __free_hook;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*然后将hook函数设置为未初始化版本（青春版）*/</span></span><br><span class="line">__malloc_hook = malloc_starter;</span><br><span class="line">__memalign_hook = memalign_starter;</span><br><span class="line">__free_hook = free_starter;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="comment">/* Initialize the pthreads interface. </span></span><br><span class="line"><span class="comment">调用__pthread_initialize函数初始化pthread*/</span></span><br><span class="line"><span class="keyword">if</span> (__pthread_initialize != <span class="literal">NULL</span>)</span><br><span class="line">__pthread_initialize();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* !defined _LIBC */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* !defined NO_STARTER */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* !defined NO_THREADS */</span></span><br></pre></td></tr></table></figure>
<h5 id="这里插入一下-pthread-initialize函数代码"><a href="#这里插入一下-pthread-initialize函数代码" class="headerlink" title="这里插入一下__pthread_initialize函数代码"></a>这里插入一下__pthread_initialize函数代码</h5><p> 首先初始化主分配区的 mutex，并将主分配区的 next 指针指向自身组成环形链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;main_arena.mutex);</span><br><span class="line">main_arena.next = &amp;main_arena;</span><br></pre></td></tr></table></figure>
<p> 然后保证只有主分配区才能使用 sbrk()分配连续虚拟内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC &amp;&amp; defined SHARED</span></span><br><span class="line"><span class="comment">/* In case this libc copy is in a non-default namespace, never use brk.</span></span><br><span class="line"><span class="comment">Likewise if dlopened from statically linked program. </span></span><br><span class="line"><span class="comment">保证处于主分配区时才能使用sbrk分配连续的虚拟内存空间*/</span></span><br><span class="line">Dl_info di;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line"><span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">|| (_dl_addr (ptmalloc_init, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">&amp;&amp; l-&gt;l_ns != LM_ID_BASE))<span class="comment">/*一堆判断，看下面的描述*/</span></span><br><span class="line">__morecore = __failing_morecore;<span class="comment">/*__morecore 默认指向 sbrk()，指向__failing_morecore以禁用sbrk函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>大多数情况下 Glibc 库都是以动态链接库<br>的形式加载的，处于默认命名空间，多个进程共用 Glibc 库，Glibc 库代码段在内存中只有一份拷贝，数据段在每个用户进程都有一份拷贝。但如果 Glibc 库不在默认名字空间，或是用户程序是静态编译的并调用了 dlopen 函数加载 Glibc 库中的 ptamalloc_init()，这种情况下的ptmalloc 不允许使用 sbrk()分配内存，只需修改__morecore 函数指针指向__failing_morecore就可以禁止使用 sbrk()了，__morecore 默认指向 sbrk()。</p>
</li>
</ol>
<p> 最后执行几个初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化全局锁list_lock*/</span></span><br><span class="line">mutex_init(&amp;list_lock);<span class="comment">/*list_lock 主要用于同步分配区的单向循环链表*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建线程私有实例 arena_key*/</span></span><br><span class="line">tsd_key_create(&amp;arena_key, <span class="literal">NULL</span>);<span class="comment">/*该私有实例保存的是分配区（arena）的 malloc_state 实例指针*/</span></span><br><span class="line"></span><br><span class="line">tsd_setspecific(arena_key, (Void_t *)&amp;main_arena);<span class="comment">/*将arena_key 绑定到主分配区上。意味着本线程首选从主分配区分配内存。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用 thread_atfork()设置当前进程在 fork 子线程时处理 mutex 的回调函数*/</span></span><br><span class="line">thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</span><br></pre></td></tr></table></figure>
<p>thread_atfork的详细解释：在本进程fork子进程时，调用ptmalloc_lock_all()获得所有分配区的锁，禁止所有分配区分配内存，当子进程创建完毕，父进程调用ptmalloc_unlock_all()重新unlock 每个分配区的锁mutex，子进程调用ptmalloc_unlock_all2()重新初始化每个分配区的锁 mutex。</p>
<h5 id="继续讲ptmalloc-init函数"><a href="#继续讲ptmalloc-init函数" class="headerlink" title="继续讲ptmalloc_init函数"></a>继续讲ptmalloc_init函数</h5><ol start="3">
<li><p>当 pthread 初始化完成后，将相应的 hooks 函数还原为原值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_THREADS</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_STARTER</span></span><br><span class="line">__malloc_hook = save_malloc_hook;</span><br><span class="line">__memalign_hook = save_memalign_hook;</span><br><span class="line">__free_hook = save_free_hook;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">undef</span> NO_STARTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>从环境变量中读取相应的配置参数值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">secure = __libc_enable_secure;</span><br><span class="line">s = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (_environ != <span class="literal">NULL</span>, <span class="number">1</span>))<span class="comment">/*如果环境变量非空*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> **runp = _environ;</span><br><span class="line"><span class="type">char</span> *envline;</span><br><span class="line"><span class="keyword">while</span> (__builtin_expect ((envline = next_env_entry (&amp;runp)) != <span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strcspn</span> (envline, <span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (envline[len] != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="comment">/* This is a &quot;MALLOC_&quot; variable at the end of the string</span></span><br><span class="line"><span class="comment">without a &#x27;=&#x27; character. Ignore it since otherwise we</span></span><br><span class="line"><span class="comment">will access invalid memory below. */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">switch</span> (len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;CHECK_&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">s = &amp;envline[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TOP_PAD_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_TOP_PAD, atoi(&amp;envline[<span class="number">9</span>]));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;PERTURB_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_PERTURB, atoi(&amp;envline[<span class="number">9</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_MAX_&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_MMAP_MAX, atoi(&amp;envline[<span class="number">10</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_MAX&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_ARENA_MAX, atoi(&amp;envline[<span class="number">10</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_TEST&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_ARENA_TEST, atoi(&amp;envline[<span class="number">11</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TRIM_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_TRIM_THRESHOLD, atoi(&amp;envline[<span class="number">16</span>]));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">mALLOPt(M_MMAP_THRESHOLD, atoi(&amp;envline[<span class="number">16</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_TRIM_THRESHOLD_&quot;</span>)))</span><br><span class="line">mALLOPt(M_TRIM_THRESHOLD, atoi(s));</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_TOP_PAD_&quot;</span>)))</span><br><span class="line">mALLOPt(M_TOP_PAD, atoi(s));</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_PERTURB_&quot;</span>)))</span><br><span class="line">mALLOPt(M_PERTURB, atoi(s));</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_MMAP_THRESHOLD_&quot;</span>)))</span><br><span class="line">mALLOPt(M_MMAP_THRESHOLD, atoi(s));</span><br><span class="line"><span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_MMAP_MAX_&quot;</span>)))</span><br><span class="line">mALLOPt(M_MMAP_MAX, atoi(s));</span><br><span class="line">&#125;</span><br><span class="line">s = getenv(<span class="string">&quot;MALLOC_CHECK_&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span>(s &amp;&amp; s[<span class="number">0</span>]) &#123;</span><br><span class="line">mALLOPt(M_CHECK_ACTION, (<span class="type">int</span>)(s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="keyword">if</span> (check_action != <span class="number">0</span>)</span><br><span class="line">__malloc_check_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些参数包括 MALLOC_TRIM_THRESHOLD_，MALLOC_TOP_PAD_，MALLOC_PERTURB_，MALLOC_MMAP_THRESHOLD_，MALLOC_CHECK_MALLOC_MMAP_MAX_，MALLOC_ ARENA_MAX,MALLOC_ ARENA_TEST,如果这些选项中的某些项存在，调用 mallopt()函数设置相应的选项。如果这段程序是在 Glibc 库初始化中执行的，会做更多的安全检查工作。仅仅是配置环境变量，不必过于关心。</p>
</li>
<li><p>最后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__malloc_initialize_hook);</span><br><span class="line"><span class="keyword">if</span> (hook != <span class="literal">NULL</span>)<span class="comment">/*查看是否存在__malloc_initialize_hook 函数*/</span></span><br><span class="line">(*hook)();<span class="comment">/*存在，则执行*/</span></span><br><span class="line">__malloc_initialized = <span class="number">1</span>;<span class="comment">/*设为1，表示初始化完成*/</span></span><br></pre></td></tr></table></figure>
<p>注意这里是在ptmalloc当中的hook变量，之前那个是在public_mALLOc函数里面，用一幅图来描述初始化过程：</p>
</li>
</ol>
<p><img src="/images/images/ptmalloc_ini.png" alt="alt ptmalloc_ini"></p>
<h3 id="fork机制创建新进程的相关函数"><a href="#fork机制创建新进程的相关函数" class="headerlink" title="fork机制创建新进程的相关函数"></a>fork机制创建新进程的相关函数</h3><ol>
<li>当父进程中的某个线程使用fork的机制创建子进程时，首先调用 ptmalloc_lock_all()函数暂时对全局锁list_lock和所有的分配区加锁，从而保证分配区状态的一致性。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Counter for number of times the list is locked by the same thread. </span></span><br><span class="line"><span class="comment">一个全局计数器，记录这个list被同一个进程加锁的次数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> atfork_recursive_cntr;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_lock_all</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">mstate ar_ptr;<span class="comment">/*分配区指针*/</span></span><br><span class="line"><span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)<span class="comment">/*若ptmalloc没有初始化，则退出*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (mutex_trylock(&amp;list_lock))<span class="comment">/*mutex_lock的非阻塞版本，获得锁，如果失败，不会等待，直接返回0*/</span></span><br><span class="line">&#123;</span><br><span class="line">Void_t *my_arena;</span><br><span class="line">tsd_getspecific(arena_key, my_arena);<span class="comment">/*获得线程私有实例</span></span><br><span class="line"><span class="comment">中的分配区指针*/</span></span><br><span class="line"><span class="keyword">if</span> (my_arena == ATFORK_ARENA_PTR)<span class="comment">/*如果正在fork线程*/</span></span><br><span class="line"><span class="comment">/* This is the same thread which already locks the global list.Just bump the counter. </span></span><br><span class="line"><span class="comment">说明这是已经对分配区加了锁的线程*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> out;<span class="comment">/*直接跳出*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This thread has to wait its turn. </span></span><br><span class="line"><span class="comment">尝试获得全局锁list_lock，直到获得为止*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;<span class="comment">/*对所有分配区加锁*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">ar_ptr = ar_ptr-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*保存原来的free_hook和malloc_hook*/</span></span><br><span class="line">save_malloc_hook = __malloc_hook;</span><br><span class="line">save_free_hook = __free_hook;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将 malloc_atfork()和 free_atfork()函数作为 fork 子进程期间所使用的内存分配释放函数*/</span></span><br><span class="line">__malloc_hook = malloc_atfork;</span><br><span class="line">__free_hook = free_atfork;</span><br><span class="line"><span class="comment">/* Only the current thread may perform malloc/free calls now. */</span></span><br><span class="line"></span><br><span class="line">tsd_getspecific(arena_key, save_arena);<span class="comment">/*保存当前线程的私有实例中的原有分配区指针*/</span></span><br><span class="line">tsd_setspecific(arena_key, ATFORK_ARENA_PTR);<span class="comment">/*将ATFORK_ARENA_PTR 存放到当前线程的私有实例中，用于标识当前现在正在 fork 子进程。*/</span></span><br><span class="line">out:</span><br><span class="line">++atfork_recursive_cntr;<span class="comment">/*给计数器加1*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：为了保证父线程 fork 多个子进程工作正常，也就是说当前线程需要 fork 多个子进程，当一个子进程已经创建，当前线程继续创建其它子进程时，发现当前线程已经对 list_lock 和所有分配区加锁，于是对全局变量 atfork_recursive_cntr 加 1，表示递归 fork 子进程的层数，保证父进程在fork子进程过程中，调用ptmalloc_unlock_all()函数解锁的次数与调用ptmalloc_lock_all()函数加锁的次数保持一致，同时也保证保证所有的子进程调用ptmalloc_unlock_all()函数解锁的次数与父进程调用 ptmalloc_lock_all()函数加锁的次数保持一致，防止没有释放锁。</p>
<ol start="2">
<li><p>当父进程中的某个线程使用 fork 的机制创建子进程时，如果该线程中需要分配内存，将使用 malloc_atfork()函数分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Magic value for the thread-specific arena pointer when</span></span><br><span class="line"><span class="comment">malloc_atfork() is in use. </span></span><br><span class="line"><span class="comment">魔数，用于标志本线程正在 fork 新进程，并锁住了全局锁 </span></span><br><span class="line"><span class="comment">list_lock 和每个分配区，当前只有本线程可以分配内存*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATFORK_ARENA_PTR ((Void_t*)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following hooks are used while the `atfork&#x27; handling mechanismis active. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Void_t*</span><br><span class="line"><span class="title function_">malloc_atfork</span><span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> Void_t *caller)</span></span><br><span class="line">&#123;</span><br><span class="line">Void_t *vptr = <span class="literal">NULL</span>;</span><br><span class="line">Void_t *victim;</span><br><span class="line">tsd_getspecific(arena_key, vptr);<span class="comment">/*获取自己的线程私有实例中的分配区指针vptr*/</span></span><br><span class="line"><span class="keyword">if</span>(vptr == ATFORK_ARENA_PTR) &#123;</span><br><span class="line"><span class="comment">/* We are the only thread that may allocate at all. </span></span><br><span class="line"><span class="comment">若vptr == ATFORK_ARENA_PTR，此时我们是唯一可以分配内存的线程*/</span></span><br><span class="line"><span class="keyword">if</span>(save_malloc_hook != malloc_check) &#123;<span class="comment">/*如果在 fork 线程前的分配函数不是处于 check 模式*/</span></span><br><span class="line"><span class="keyword">return</span> _int_malloc(&amp;main_arena, sz);<span class="comment">/*直接调用内部分配函数_int_malloc()*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">/*在分配内存的同时做检查。*/</span></span><br><span class="line"><span class="keyword">if</span>(top_check()&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">victim = _int_malloc(&amp;main_arena, sz+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> mem2mem_check(victim, sz);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Suspend the thread until the `atfork&#x27; handlers have completed.</span></span><br><span class="line"><span class="comment">By that time, the hooks will have been reset as well, so that</span></span><br><span class="line"><span class="comment">mALLOc() can be used again. </span></span><br><span class="line"><span class="comment">如果线程私有实例中的指针不是ATFORK_ARENA_PTR，意味着当前线程只是常规线</span></span><br><span class="line"><span class="comment">程，有另外的线程在 fork 子进程，当前线程只能等待 fork 子进程的线程完成分配*/</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;list_lock);<span class="comment">/*获得全局锁 list_lock*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;list_lock);<span class="comment">/*释放全局锁 list_lock*/</span></span><br><span class="line"><span class="keyword">return</span> public_mALLOc(sz);<span class="comment">/*调用 public_mALLOc()分配内存*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：调用mutex_lock()函数获得全局锁时，若全局锁被占用，则等待。此处若获得全局锁成功，表示 fork 子线程的线程已经完成 fork 操作，当前线程可以分配内存了，于是是释放全局所 list_lock，并调用 public_mALLOc()分配内存。</p>
</li>
<li><p>当父进程中的某个线程使用 fork 的机制创建子进程时，如果进程中的线程需要释放内存，将使用 free_atfork()函数释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">free_atfork</span><span class="params">(Void_t* mem, <span class="type">const</span> Void_t *caller)</span></span><br><span class="line">&#123;</span><br><span class="line">Void_t *vptr = <span class="literal">NULL</span>;</span><br><span class="line">mstate ar_ptr;</span><br><span class="line">mchunkptr p;</span><br><span class="line"><span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"><span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* free(0) has no effect </span></span><br><span class="line"><span class="comment">free 0 是无用的，直接退出*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">p = mem2chunk(mem);<span class="comment">/*将用户使用的内存指针转换为对应chunk指针*/</span></span><br><span class="line"><span class="comment">/* do not bother to replicate free_check here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p))<span class="comment">/*这个chunk是mmap分配的*/</span></span><br><span class="line"><span class="comment">/* release mmapped memory. </span></span><br><span class="line"><span class="comment">释放mmap空间*/</span></span><br><span class="line">&#123;</span><br><span class="line">munmap_chunk(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS<span class="comment">/*如果开启了 ATOMIC_FASTBINS 优化*/</span></span></span><br><span class="line">ar_ptr = arena_for_chunk(p);<span class="comment">/*获得chunk对应的分配区指针*/</span></span><br><span class="line">tsd_getspecific(arena_key, vptr);<span class="comment">/*获取自己的线程私有实例中的分配区指针vptr*/</span></span><br><span class="line">_int_free(ar_ptr, p, vptr == ATFORK_ARENA_PTR);<span class="comment">/*直接调用_int_free函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">/*没有开启ATOMIC_FASTBINS 优化*/</span></span></span><br><span class="line">ar_ptr = arena_for_chunk(p);</span><br><span class="line">tsd_getspecific(arena_key, vptr);</span><br><span class="line"><span class="keyword">if</span>(vptr != ATFORK_ARENA_PTR)<span class="comment">/*如果当前线程没有正在 fork 新子线程*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);<span class="comment">/*给分配区加锁*/</span></span><br><span class="line">_int_free(ar_ptr, p);<span class="comment">/*调用_int_free函数*/</span></span><br><span class="line"><span class="keyword">if</span>(vptr != ATFORK_ARENA_PTR)</span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);<span class="comment">/*解锁*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于正在 fork 子进程的线程来说，是不需要对分配区加锁的，因为该线程已经对所有的分配区加锁了。</p>
</li>
<li><p>当进程的某个线程完成 fork 子线程后，父进程调用 ptmall_unlock_all()函数释放全局锁 list_lock，释放所有分配区的锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_unlock_all</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">mstate ar_ptr;</span><br><span class="line"><span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)<span class="comment">/*没有初始化ptalloc就直接退出*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (--atfork_recursive_cntr != <span class="number">0</span>)<span class="comment">/*计数器减1，若不为零，说明锁了多次，由上面ptmalloc_lock_all</span></span><br><span class="line"><span class="comment">可知，多次锁实际只锁了一次，其余都是计数器加1，故减1后直接退出，保证只解锁一次*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">tsd_setspecific(arena_key, save_arena);<span class="comment">/*还原*分配区指针/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*还原hook函数*/</span></span><br><span class="line">__malloc_hook = save_malloc_hook;</span><br><span class="line">__free_hook = save_free_hook;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解锁所有的分配区*/</span></span><br><span class="line"><span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;</span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">ar_ptr = ar_ptr-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解锁list_lock*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，在Linux系统中，子进程unlock从父进程中继承的mutex不安全，会导致资源泄漏，但重新初始化 mutex是安全的，所以增加了这个特殊版本ptmalloc_unlock_all2用于Linux下的子进程解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_unlock_all2</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">mstate ar_ptr;</span><br><span class="line"><span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined MALLOC_HOOKS</span></span><br><span class="line">tsd_setspecific(arena_key, save_arena);</span><br><span class="line">__malloc_hook = save_malloc_hook;</span><br><span class="line">__free_hook = save_free_hook;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">free_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;</span><br><span class="line">mutex_init(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD<span class="comment">/*如果开启了 PER_THREAD 的优化*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将从父进程中继承来的分配区加入到 free_list (一个倒着走的单向链表)中*/</span></span><br><span class="line"><span class="keyword">if</span> (ar_ptr != save_arena) &#123;</span><br><span class="line">ar_ptr-&gt;next_free = free_list;</span><br><span class="line">free_list = ar_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">ar_ptr = ar_ptr-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_init(&amp;list_lock);<span class="comment">/*用 mutex_init()代替了 mutex_unlock()，重新初始化 mutex*/</span></span><br><span class="line">atfork_recursive_cntr = <span class="number">0</span>;<span class="comment">/*子进程不会继续递归fork，因此可以直接解锁，将计数器置为0*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ptmalloc_unlock_all2 ptmalloc_unlock_all</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="关于线程和进程的疑惑"><a href="#关于线程和进程的疑惑" class="headerlink" title="关于线程和进程的疑惑"></a>关于线程和进程的疑惑</h3><p>如果读到这里，相信你会大骂，写的什么鬼东西，作者真是个傻宝，其实我当时读的时候也很迷惑（原作写的是fork线程，这里我修改为了进程），fork怎么会创建线程，线程共享全局变量和数据，代码，怎么可能父线程和子线程同时占用一个锁。<br>但实际上，linux本来是没有线程的，fork创建进程会复制父进程原来的状态，并且在内核task结构体中赋予新的pid，并且子进程与父进程是隔离的。后来线程出现了，为了紧跟潮流（bushi），linux也加入了线程，linux的线程仅仅是开辟了一个新的空间作为线程的栈，还创建了一个结构体用于保存线程的信息（寄存器等），代码段和数据段与父线程共享。问题来了，假如我们在一个线程中fork一个子进程会怎么样？（请自己百度）<br>上面就是在多线程的情况下，fork子线程时，为了保护资源（分配区等）所采取的措施。</p>
</li>
</ol>
<h3 id="多分配区支持"><a href="#多分配区支持" class="headerlink" title="多分配区支持"></a>多分配区支持</h3><p>由于只有一个主分配区从堆中分配小内存块，而稍大的内存块都必须从 mmap 映射区域分配，如果有多个线程都要分配小内存块，但多个线程是不能同时调用 sbrk()函数的，因为只有一个函数调用 sbrk()时才能保证分配的虚拟地址空间是连续的。如果多个线程都从主分配区中分配小内存块，效率很低效。为了解决这个问题，ptmalloc 使用非主分配区来模拟主分配区的功能，非主分配区同样可以分配小内存块，并且可以创建多个非主分配区，从而在线程分配内存竞争比较激烈的情况下，可以创建更多的非主分配区来完成分配任务，减少分配区的锁竞争，提高分配效率。<br>Ptmalloc 怎么用非主分配区来模拟主分配区的行为呢？首先创建一个新的非主分配区，非主分配区使用 mmap()函数分配一大块内存来模拟堆（sub-heap），所有的从该非主分配区分配的小内存块都从 sub-heap 中切分，如果一个 sub-heap 的内存用光了，或是sub-heap 中的内存不够用时，使用 mmap()分配一块新的内存块作为 sub-heap，并将新sub-heap 链接在非主分配区中 sub-heap 的单向链表中。<br>非主分配区中的 sub-heap 所占用的内存不会无限的增长下去，同样会像主分配区那样进行进行 sub-heap 收缩，将 sub-heap 中 top chunk 的一部分返回给操作系统，如果 top chunk为整个 sub-heap，会把整个 sub-heap 还回给操作系统。收缩堆的条件是当前 free 的 chunk大小加上前后能合并 chunk 的大小大于 64KB，并且 top chunk 的大小达到 mmap 收缩阈值，才有可能收缩堆。<br>一般情况下，进程中有多个线程，也有多个分配区，线程的数据一般会比分配区数量多，所以必能保证没有线程独享一个分配区，每个分配区都有可能被多个线程使用，为了保证分配区的线程安全，对分配区的访问需要锁保护，当线程获得分配区的锁时，可以使用该分配区分配内存，并将该分配区的指针保存在线程的私有实例中。当某一线程需要调用 malloc 分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜分配区索循环链表试图获得一个空闲的分配区。如果所有的分配区都已经加锁，那么 malloc 会开辟一个新的分配区，把该分配区加入到分配区的全局分配区循环链表并加锁，然后使用该分配区进行分配操作。在回收操作中，线程同样试图获得待回收块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行回收操作。</p>
<h4 id="Heap-info"><a href="#Heap-info" class="headerlink" title="Heap_info"></a>Heap_info</h4><p>heap_info结构体是保存sub-heap信息的结构体<br>Struct heap_info 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> &#123;</span></span><br><span class="line">mstate ar_ptr;</span><br><span class="line"><span class="comment">/* Arena for this heap. </span></span><br><span class="line"><span class="comment">这个堆所属的分配区指针*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="comment">/* Previous heap. </span></span><br><span class="line"><span class="comment">指向前一个堆的指针，用于将属于同一分配区的sub-heap连起来*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="comment">/* Current size in bytes. </span></span><br><span class="line"><span class="comment">当前的大小（byte）*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> mprotect_size;</span><br><span class="line"><span class="comment">/* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. </span></span><br><span class="line"><span class="comment">当前sub-heap中被读写保护的内存大小（即没有被分配的内存大小）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">MALLOC_ALIGNMENT. </span></span><br><span class="line"><span class="comment">保证sizeof(heap_info)+2*SIZE_SZ是按MALLOC_ALIGNMENT对齐的，不对齐编译时会报错*/</span></span><br><span class="line"><span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<span class="comment">/*MALLOC_ALIGNMENT_MASK 为 2 * SIZE_SZ - 1，无论 SIZE_SZ 为 4 或 8，</span></span><br><span class="line"><span class="comment">-6 * SIZE_SZ &amp;MALLOC_ALIGN_MASK的值为0*/</span></span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<p>为什么一定要保证对齐呢？作为分主分配区的第一个 sub_heap，heap_info 存放在sub_heap 的头部，紧跟 heap_info 之后是该非主分配区的 malloc_state 实例，紧跟 malloc_state实例后，是 sub_heap 中的第一个 chunk，但 chunk 的首地址必须按照 MALLOC_ALIGNMENT对齐，所以在 malloc_state 实例和第一个 chunk 之间可能有几个字节的 pad，但如果 sub_heap不是非主分配区的第一个 sub_heap，则紧跟 heap_info 后是第一个 chunk，但 sysmalloc()函数默认 heap_info 是按照 MALLOC_ALIGNMENT 对齐的，没有再做对齐的工作，直接将heap_info 后的内存强制转换成一个 chunk。所以这里在编译时保证 sizeof (heap_info) + 2 *SIZE_SZ 是按 MALLOC_ALIGNMENT 对齐的，在运行时就不用再做检查了，也不必再做对齐。</p>
<h4 id="获取分配区"><a href="#获取分配区" class="headerlink" title="获取分配区"></a>获取分配区</h4><ol>
<li><p>为了支持多线程，ptmalloc 定义了如下的全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">tsd_key_t</span> arena_key;<span class="comment">/*arena_key 存放的是线程的私用实例，该私有实例保存的是分配区（arena）的 malloc_state实例的指针。</span></span><br><span class="line"><span class="comment">arena_key 指向的可能是主分配区的指针，也可能是非主分配区的指针。前面讲过，当为ATFORK_ARENA_PTR时说明正在fork子进程</span></span><br><span class="line"><span class="comment">存放在线程的结构体中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> list_lock;<span class="comment">/*一个锁，list_lock 用于同步分配区的单向环形链表。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> narenas;<span class="comment">/*表示当前分配区数量*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> mstate free_list;<span class="comment">/*指向空闲分配区的单向循环链表*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/* Mapped memory in non-main arenas (reliable only for NO_THREADS). </span></span></span><br><span class="line"><span class="comment"><span class="meta">arena_mem只用于单线程的ptmalloc版本，记录了非主分配区所分配的内存大小*/</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> arena_mem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Already initialized? </span></span><br><span class="line"><span class="comment">表示pt；malloc是否已初始化，大于0表示已经初始化*/</span></span><br><span class="line"><span class="type">int</span> __malloc_initialized = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>ptmalloc使用以下的宏来获取分配区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \<span class="comment">/*获取分配区*/</span></span></span><br><span class="line"></span><br><span class="line">arena_lookup(ptr); \<span class="comment">/*查找本线程的私用实例中是否包含一个分配区的指针，返回该指针*/</span></span><br><span class="line">arena_lock(ptr, size); \<span class="comment">/*尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果对该分配区加锁失败，调用 arena_get2 获得一个分配区指针*/</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)<span class="comment">/*不明白为什么写成一个循环*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lookup(ptr) do &#123; \<span class="comment">/*获得线程的分配区指针*/</span></span></span><br><span class="line">Void_t *vptr = <span class="literal">NULL</span>; \</span><br><span class="line">ptr = (mstate)tsd_getspecific(arena_key, vptr); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="comment">/*开启PER_THREAD优化时的arena_lock宏*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span>(ptr) \<span class="comment">/*如果这个线程私有实例有分配区指针*/</span></span></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;ptr-&gt;mutex); \<span class="comment">/*尝试获取分配区的锁*/</span></span><br><span class="line"><span class="keyword">else</span> \<span class="comment">/*否则*/</span></span><br><span class="line">ptr = arena_get2(ptr, (size)); \<span class="comment">/*调用arena_get2获得一个分配区指针*/</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">/*没有定义PER_THREAD时的arena_lock宏*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span>(ptr &amp;&amp; !mutex_trylock(&amp;ptr-&gt;mutex)) &#123; \<span class="comment">/*如果分配区指针存在，且尝试加锁（非阻塞的）成功*/</span></span></span><br><span class="line">THREAD_STAT(++(ptr-&gt;stat_lock_direct)); <span class="comment">/*分配区的stat_lock_direct变量加1*/</span>\</span><br><span class="line">&#125; <span class="keyword">else</span> \<span class="comment">/*失败*/</span></span><br><span class="line">ptr = arena_get2(ptr, (size)); \<span class="comment">/*调用arena_get2获得一个分配区指针*/</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/* find the heap and corresponding arena for a given ptr </span></span></span><br><span class="line"><span class="comment"><span class="meta">通过分配区地址获得sub-heap地址，注意上文提到的sub-heap和分配区的位置关系*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">((heap_info *)((unsigned long)(ptr) &amp; ~(HEAP_MAX_SIZE-1)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \<span class="comment">/*通过chunk地址获得分配区地址*/</span></span></span><br><span class="line">(chunk_non_main_arena(ptr) ? heap_for_ptr(ptr)-&gt;ar_ptr : &amp;main_arena)</span><br><span class="line"><span class="comment">/*这里直接获得sub-heap地址，sub-heap的开头保存的时heap_info实例（结构体）*/</span></span><br></pre></td></tr></table></figure>
<p>注意：之前一直称为结构体，当用于具体作用的时候，应称为实例。</p>
</li>
<li><p>几个全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32*1024) <span class="comment">/*sub-heap的最小值*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE<span class="comment">/*sub-heap的最大值*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*HEAP_MAX_SIZE分为不同位数操作系统下的不同定义*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HEAP_MAX_SIZE (1024*1024)</span></span><br><span class="line"><span class="comment">/* must be a power of two */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Arena-get2-函数解析"><a href="#Arena-get2-函数解析" class="headerlink" title="Arena_get2()函数解析"></a>Arena_get2()函数解析</h4><p>上文提到arena_get 宏尝试查看线程的私用实例中是否包含一个分配区，如果不存在分配区或是存在分配区，但对该分配区加锁失败，就会调用 arena_get2()函数获得一个分配区，下面将分析 arena_get2()函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">internal_function</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">arena_get2(mstate a_tsd, <span class="type">size_t</span> size)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">arena_get2(a_tsd, size) mstate a_tsd; <span class="type">size_t</span> size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">mstate a;<span class="comment">/*定义一个候选分配区指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD<span class="comment">/*如果开启了PER_THREAD优化*/</span></span></span><br><span class="line"><span class="keyword">if</span> ((a = get_free_list ()) == <span class="literal">NULL</span></span><br><span class="line">&amp;&amp; (a = reused_arena ()) == <span class="literal">NULL</span>)<span class="comment">/*尝试从freelist中获得一个空闲的分配区，没有分配区是空闲的，就重用一个分配区*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Nothing immediately available, so generate a new arena. </span></span><br><span class="line"><span class="comment">都不行，生成一个新的*/</span></span><br><span class="line">a = _int_new_arena(size);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">/*如果没有开启优化*/</span></span></span><br><span class="line"><span class="keyword">if</span>(!a_tsd)<span class="comment">/*如果线程的实例中没有分配区*/</span></span><br><span class="line">a = a_tsd = &amp;main_arena;<span class="comment">/*先弄成主分配区作为候选*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">/*如果有分配区*/</span></span><br><span class="line">a = a_tsd-&gt;next;<span class="comment">/*让下一个分配区作为候选*/</span></span><br><span class="line"><span class="keyword">if</span>(!a) &#123;<span class="comment">/*下一个分配区不存在*/</span></span><br><span class="line"><span class="comment">/* This can only happen while initializing the new arena. </span></span><br><span class="line"><span class="comment">当前实例的分配区正在初始化，还没有加入到全局分配区链表（因为正常情况下是循环链表）*/</span></span><br><span class="line"><span class="comment">/*只有主分配区可选了*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;main_arena.mutex);<span class="comment">/*尝试获取主分配区的锁*/</span></span><br><span class="line">THREAD_STAT(++(main_arena.stat_lock_wait));</span><br><span class="line"><span class="keyword">return</span> &amp;main_arena;<span class="comment">/*返回主分配区指针*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> retried = <span class="literal">false</span>;<span class="comment">/*布尔值，表示是否是二次遍历全局分配区链表*/</span></span><br><span class="line">repeat:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(!mutex_trylock(&amp;a-&gt;mutex)) &#123;<span class="comment">/*尝试给候选分配区加锁（非阻塞）*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retried)<span class="comment">/*如果已经是二次遍历（此时一定已经对全局分配区链表加锁了），需要解下锁再设置分配区*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;list_lock);<span class="comment">/*给全局分配区链表解锁*/</span></span><br><span class="line"></span><br><span class="line">THREAD_STAT(++(a-&gt;stat_lock_loop));</span><br><span class="line">tsd_setspecific(arena_key, (Void_t *)a);<span class="comment">/*将当前线程的分配区指针设置为候选分配区指针*/</span></span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">/*返回*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a = a-&gt;next;<span class="comment">/*说明加锁失败了，指向下一个分配区（失败返回非0，成功返回0）*/</span></span><br><span class="line">&#125; <span class="keyword">while</span>(a != a_tsd);<span class="comment">/*只要分配区没有遍历完，就循环*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!retried &amp;&amp; mutex_trylock(&amp;list_lock)) &#123;<span class="comment">/*如果是第一次遍历，且给全局分配区加锁失败*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*说明有线程在创建子进程或者正在获得分配区，占用了全局分配区链表的锁*/</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;list_lock);<span class="comment">/*继续给全局分配区链表加锁，等待直到成功*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Since we blocked there might be an arena available now. </span></span><br><span class="line"><span class="comment">等待全局分配区链表加锁的时间，可能已经有分配区可用了*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们就再去遍历一次*/</span></span><br><span class="line">retried = <span class="literal">true</span>;<span class="comment">/*把二次遍历的标志设置为true*/</span></span><br><span class="line">a = a_tsd;<span class="comment">/*让候选分配区指针指向开始的分配区（回到起点）*/</span></span><br><span class="line"><span class="keyword">goto</span> repeat;<span class="comment">/*跳到遍历循环处*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Nothing immediately available, so generate a new arena. </span></span><br><span class="line"><span class="comment">上面都失败了，说明当前真的没有分配区可用了*/</span></span><br><span class="line">a = _int_new_arena(size);<span class="comment">/*生成一个新的分配区，并加入分配区链表*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;list_lock);<span class="comment">/*释放list_lock*/</span></span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">/*返回新分配区指针*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="对上面的-int-new-arena-函数解析"><a href="#对上面的-int-new-arena-函数解析" class="headerlink" title="对上面的_int_new_arena()函数解析"></a>对上面的_int_new_arena()函数解析</h4><p>_int_new_arena()函数用于创建一个非主分配区，在 arena_get2()函数中被调用，该函数的实现代码如下（按顺序分部分解析）：</p>
<p>1. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">_int_new_arena(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">mstate a;<span class="comment">/*临时的分配区指针*/</span></span><br><span class="line">heap_info *h;<span class="comment">/*临时的heap-info结构体指针*/</span></span><br><span class="line"><span class="type">char</span> *ptr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> misalign;</span><br><span class="line">h = new_heap(size + (<span class="keyword">sizeof</span>(*h) + <span class="keyword">sizeof</span>(*a) + MALLOC_ALIGNMENT),</span><br><span class="line">mp_.top_pad);<span class="comment">/*分配sub-heap*/</span></span><br><span class="line"><span class="keyword">if</span>(!h) &#123;<span class="comment">/*如果分配失败*/</span></span><br><span class="line"><span class="comment">/* Maybe size is too large to fit in a single heap. So, just tryto create a minimally-sized arena and </span></span><br><span class="line"><span class="comment">let _int_malloc() attemptto deal with the large request via mmap_chunk(). </span></span><br><span class="line"><span class="comment">或许size太大了，尝试创建一个更小的子堆*/</span></span><br><span class="line">h = new_heap(<span class="keyword">sizeof</span>(*h) + <span class="keyword">sizeof</span>(*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line"><span class="keyword">if</span>(!h)<span class="comment">/*还是不行*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/*直接退出，返回0*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个新的非主分配区，至少包含一个 sub_heap，每个非主分配区中都有相应的管理数据结构，每个非主分配区都有一个 heap_info 实例和 malloc_state 的实例，这两个实例都位于非主分配区的第一个 sub_heap 的开始部分，malloc_state 实例紧接着 heap_info 实例。所以在创建非主分配区时，需要为管理数据结构分配额外的内存空间。New_heap()函数创建一个新的 sub_heap，并返回 sub_heap 的指针。</p>
<p>2. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a = h-&gt;ar_ptr = (mstate)(h+<span class="number">1</span>);<span class="comment">/*这里把h当作heap-info结构体指针来使用*/</span></span><br><span class="line"><span class="comment">/*在 heap_info 实例后紧接着 malloc_state 实例，初始化 malloc_state 实例，更新该分配区所分配的内存大小的统计值。*/</span></span><br><span class="line"></span><br><span class="line">malloc_init_state(a);<span class="comment">/*初始化新分配区malloc_state实例*/</span></span><br><span class="line"><span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;<span class="comment">/*设置分配区可分配内存大小*/</span></span><br><span class="line">arena_mem += h-&gt;size;<span class="comment">/*h继续当作heap_info结构体指针来使用*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_THREADS</span></span><br><span class="line"><span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmapped_mem + arena_mem + main_arena.system_mem) &gt;</span><br><span class="line">mp_.max_total_mem)</span><br><span class="line">mp_.max_total_mem = mp_.mmapped_mem + arena_mem + main_arena.system_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/* Set up the top chunk, with proper alignment. */</span></span></span><br><span class="line"></span><br><span class="line">ptr = (<span class="type">char</span> *)(a + <span class="number">1</span>);<span class="comment">/*在sub_heap中malloc_state实例后的内存可以分配给用户使用，ptr指向存储malloc_state实例后的空闲内存*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对ptr 按照2*SZ_SIZE对齐*/</span></span><br><span class="line">misalign = (<span class="type">unsigned</span> <span class="type">long</span>)chunk2mem(ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line"><span class="keyword">if</span> (misalign &gt; <span class="number">0</span>)</span><br><span class="line">ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line"></span><br><span class="line">top(a) = (mchunkptr)ptr;<span class="comment">/*将 ptr 赋值给分配区的topchunk，也就是说把sub_heap中整个空闲内存块作为top chunk*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*然后设置 top chunk 的 size，并标识 top chunk 的前一个 chunk 为已处于分配状态*/</span></span><br><span class="line">set_head(top(a), (((<span class="type">char</span>*)h + h-&gt;size) - ptr) | PREV_INUSE);</span><br></pre></td></tr></table></figure>

<p>3. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tsd_setspecific(arena_key, (Void_t *)a);<span class="comment">/*将创建好的非主分配区加入线程的私有实例中*/</span></span><br><span class="line">mutex_init(&amp;a-&gt;mutex);<span class="comment">/*然后对非主分配区的锁进行初始化*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;a-&gt;mutex);<span class="comment">/*并</span></span><br><span class="line"><span class="comment">获得该锁。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD<span class="comment">/*如果开启了 PER_THREAD 优化，在arena_get2()函数中没有对全局锁 list_lock 加锁，</span></span></span><br><span class="line"><span class="comment"><span class="meta">这里修改全局分配区链表时需要获得全局锁list_lock。*/</span></span></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果没有开启 PER_THREAD 优化，arene_get2()函数调用_int_new_arena()函数时已</span></span><br><span class="line"><span class="comment">经获得了全局锁 list_lock，所以对全局分配区链表的修改不用再加锁。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the new arena to the global list. </span></span><br><span class="line"><span class="comment">将新分配区加入全局分配区链表中*/</span></span><br><span class="line">a-&gt;next = main_arena.next;</span><br><span class="line">atomic_write_barrier ();</span><br><span class="line">main_arena.next = a;</span><br><span class="line"><span class="comment">/*全局分配区链表一直保持主分配区在头部，新来的分配区接入主分配区后面*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD<span class="comment">/*开启了优化，要给分配区数目加1，并解锁*/</span></span></span><br><span class="line">++narenas;</span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">THREAD_STAT(++(a-&gt;stat_lock_loop));</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对上面出现的几个函数解析"><a href="#对上面出现的几个函数解析" class="headerlink" title="对上面出现的几个函数解析"></a>对上面出现的几个函数解析</h4><p>New_heap()函数负责从 mmap 区域映射一块内存来作为 sub_heap，在 32 位系统上，该函数每次映射 1M 内存，映射的内存块地址按 1M 对齐；在 64 为系统上，该函数映射 64M内存，映射的内存块地址按 64M 对齐。New_heap()函数只是映射一块虚拟地址空间，该空间不可读写，不会被 swap（空间内存置零）。<br> get_free_list()用于在free list中获得一个空闲的分配区。<br>reused_arena()用于尝试重用一个未加锁的分配区。<br> grow_heap()用于sub-heap的增长。<br> shrink_heap()用于sub-heap的收缩。<br> delete_heap()用于将sub-heap返还给操作系统。<br> heap_trim()根据 sub_heap 的 top chunk 大小调用 shrink_heap()函数收缩 sub_heap。<br>上面几个函数在本文的参考文章中有源码，知道功能即可。</p>
<h3 id="内存分配-malloc"><a href="#内存分配-malloc" class="headerlink" title="内存分配 malloc"></a>内存分配 malloc</h3><p>前面作的铺垫都是为了从源码层面讲解malloc和free函数，Ptmalloc2 主要的内存分配函数为 malloc()，但源代码中并不能找到该函数，该函数是用宏定义为 public_mALLOc()，因为该函数在不同的编译条件下，具有不同的名称。public_mALLOc()函数只是简单的封装_int_malloc()函数，_int_malloc()函数才是内存分配的核心实现。下面我们将分析malloc的实现。</p>
<h4 id="public-mALLOc"><a href="#public-mALLOc" class="headerlink" title="public_mALLOc()"></a>public_mALLOc()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Void_t*</span><br><span class="line"><span class="title function_">public_mALLOc</span><span class="params">(<span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">mstate ar_ptr;</span><br><span class="line">Void_t *victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*先查看是否存在内存分配的hook函数（前面讲过，请参考）*/</span></span><br><span class="line"><span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, __const <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">= force_reg (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));<span class="number">0</span></span><br><span class="line"></span><br><span class="line">arena_lookup(ar_ptr);<span class="comment">/*获取此线程私有实例中的分配区指针*/</span></span><br><span class="line">arena_lock(ar_ptr, bytes);<span class="comment">/*尝试加锁，失败会尝试获得一个新分配区*/</span></span><br><span class="line"><span class="keyword">if</span>(!ar_ptr)<span class="comment">/*还是失败了*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/*退出*/</span></span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);<span class="comment">/*调用_int_malloc()通过ar_ptr指向的分配区分配bytes字节的内存，将指针返回给victim*/</span></span><br><span class="line"><span class="keyword">if</span>(!victim) &#123;<span class="comment">/*victim为NULL*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maybe the failure is due to running out of mmapped areas. </span></span><br><span class="line"><span class="comment">或许失败原因是mmap的内存不足，试着从主分配区的heap里分配*/</span></span><br><span class="line"><span class="keyword">if</span>(ar_ptr != &amp;main_arena) &#123;<span class="comment">/*如果当前线程使用的分配区不是主分配区，用主分配区试一试*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);<span class="comment">/*给当前分配区解锁*/</span></span><br><span class="line">ar_ptr = &amp;main_arena;<span class="comment">/*切换为主分配区*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);<span class="comment">/*获得锁*/</span></span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);<span class="comment">/*再次调用_int_malloc()函数从主分配区中分配*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);<span class="comment">/*解锁*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">/*如果当前分配区就是主分配区*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_ARENAS</span></span><br><span class="line"><span class="comment">/* ... or sbrk() has failed and there is still a chance to mmap() </span></span><br><span class="line"><span class="comment">或者是sbrk()函数失败，尝试用mmap分配*/</span></span><br><span class="line"></span><br><span class="line">ar_ptr = arena_get2(ar_ptr-&gt;next ? ar_ptr : <span class="number">0</span>, bytes);<span class="comment">/*用arena_get2()函数获得一个空闲分配区，传入参数判断了非主分配区是否存在*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;main_arena.mutex);<span class="comment">/*给主分配区解锁*/</span></span><br><span class="line"><span class="keyword">if</span>(ar_ptr) &#123;<span class="comment">/*成功获得分配区*/</span></span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);<span class="comment">/*直接分配*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);<span class="comment">/*解锁*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span><span class="comment">/*victim存在，说明分配成功了*/</span></span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);<span class="comment">/*直接解锁就可以了*/</span></span><br><span class="line"></span><br><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br><span class="line"><span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="；public-mALLOc-是对-int-malloc-的封装，下面分析-int-malloc"><a href="#；public-mALLOc-是对-int-malloc-的封装，下面分析-int-malloc" class="headerlink" title="；public_mALLOc()是对_int_malloc()的封装，下面分析_int_malloc()"></a>；public_mALLOc()是对_int_malloc()的封装，下面分析_int_malloc()</h4><p>_int_malloc()函数是内存分配的核心，根据分配的内存块的大小，该函数中实现了四种分配内存的路径，下面将分别分析这四种分配路径。<br>（注意，和前面一样，是按代码顺序一次拆分的，组合到一起就是完整代码哦）</p>
<p>1.先给出_int_malloc()函数的函数定义及临时变量的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Void_t*</span><br><span class="line">_int_malloc(mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">INTERNAL_SIZE_T nb;</span><br><span class="line"><span class="comment">/* normalized request size </span></span><br><span class="line"><span class="comment">局部变量，用于储存bytes转换为需要分配的 chunk 大小nb*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx;</span><br><span class="line"><span class="comment">/* associated bin index </span></span><br><span class="line"><span class="comment">局部变量，存储bin的index*/</span></span><br><span class="line"></span><br><span class="line">mbinptr bin;</span><br><span class="line"><span class="comment">/* associated bin </span></span><br><span class="line"><span class="comment">局部变量，存储bin的指针*/</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;</span><br><span class="line"><span class="comment">/* inspected/selected chunk </span></span><br><span class="line"><span class="comment">局部变量，返回给用户使用空间的指针*/</span></span><br><span class="line"></span><br><span class="line">INTERNAL_SIZE_T size;</span><br><span class="line"><span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> victim_index;</span><br><span class="line"><span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;</span><br><span class="line"><span class="comment">/* remainder from a split </span></span><br><span class="line"><span class="comment">分割留下的remainder指针*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> remainder_size;</span><br><span class="line"><span class="comment">/* its size </span></span><br><span class="line"><span class="comment">remainder的size*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> block;</span><br><span class="line"><span class="comment">/* bit map traverser </span></span><br><span class="line"><span class="comment">在binmap中所属block*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bit;</span><br><span class="line"><span class="comment">/* bit map traverser </span></span><br><span class="line"><span class="comment">binmap中所属bit*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;</span><br><span class="line"><span class="comment">/* misc temp for linking </span></span><br><span class="line"><span class="comment">用于连接chunk的中间变量（forward）*/</span></span><br><span class="line"></span><br><span class="line">mchunkptr bck;</span><br><span class="line"><span class="comment">/* misc temp for linking </span></span><br><span class="line"><span class="comment">用于连接chunk的中间变量（back）*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;<span class="comment">/*不知道捏*/</span></span><br><span class="line"></span><br><span class="line">checked_request2size(bytes, nb);<span class="comment">/*将size转换为chunk大小，存入nb中*/</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>如果所需的 chunk 大小小于等于 fast bins 中的最大 chunk 大小，首先尝试从 fast bins 中分配 chunk。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">如果size满足fastbin的大小，先尝试从fast bin中分配，这段代码即使av（malloc_state结构体指针）</span></span><br><span class="line"><span class="comment">没有初始化也能执行，所以不检查，节约一些时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())) &#123;</span><br><span class="line">idx = fastbin_index(nb);<span class="comment">/*根据chunk大小定位bin的index*/</span></span><br><span class="line">mfastbinptr* fb = &amp;fastbin (av, idx);<span class="comment">/*获得这个bin的地址（链表头的地址，同时也是fd指针的地址），存入fb（指针的指针，因为bin中的元素就是指针啊）中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS<span class="comment">/*开启了ATOMIC_FASTBINS优化*/</span></span></span><br><span class="line">mchunkptr pp = *fb;<span class="comment">/*给pp指针赋值为fd（即第一个chunk的指针）*/</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;<span class="comment">/*反复*/</span></span><br><span class="line">victim = pp;</span><br><span class="line"><span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">!= victim);<span class="comment">/*这个循环的作用就是把chunk从链表中取出*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">/*没有开启优化*/</span></span></span><br><span class="line">victim = *fb;<span class="comment">/*victim赋值为对应bin的链表头的fd指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;<span class="comment">/*如果chunk存在（因为fd不为0）*/</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">/*如果victim指向的chunk大小不对*/</span></span><br><span class="line">&#123;</span><br><span class="line">errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/*报错并退出*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS<span class="comment">/*如果没有开启了ATOMIC_FASTBINS优化*/</span></span></span><br><span class="line">*fb = victim-&gt;fd;<span class="comment">/*fb == bin-&gt;fd,所以这里是把链表头的fd指向将要被取出chunk的下一个chunk（这样就实现了将chunk取出）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">check_remalloced_chunk(av, victim, nb);<span class="comment">/*仅在debug下才会调用，进行一些检查*/</span></span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);<span class="comment">/*定义要返回给用户使用空间的指针*/</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))<span class="comment">/*如果perturb_byte != 0,将p指向的空间每个字节的值都设为perturb_byte ^ 0xff(不知道有什么用)*/</span></span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">/*返回指针给用户*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启 ATOMIC_FASTBINS 优化，这里使用了 lock-free 的技术实现单向链表删除第一个 node 的操作。Lock-free 算法的基础是 CAS (Compareand-Swap) 原子操作。当某个地址的原始值等于某个比较值时，把值改成新值，无论有否修改，返回这个地址的原始值。目前的cpu 支持最多 64 位的 CAS，并且指针 p 必须对齐。原子操作指一个 cpu 时钟周期内就可以完成的操作，不会被其他线程干扰。一般的 CAS 使用方式是：假设有指针 p，它指向一个 32 位或者 64 位数，<br>1 复制 p 的内容（<em>p）到比较量 cmp（原子操作）。<br>2 基于这个比较量计算一个新值 xchg（非原子操作）。<br>3 调用 CAS 比较当前</em>p 和 cmp，如果相等把<em>p 替换成 xchg（原子操作）。<br>4 如果成功退出，否则回到第一步重新进行。<br>第 3 步的 CAS 操作保证了写入的同时 p 没有被其他线程更改。如果</em>p 已经被其他线程更改，那么第 2 步计算新值所使用的值（cmp）已经过期了，因此这个整个过程失败，重新来过。多线程环境下，由于 3 是一个原子操作，那么起码有一个线程（最快执行到 3）的CAS 操作可以成功，这样整体上看，就保证了所有的线程上在“前进”，而不需要使用效率低下的锁来协调线程，更不会导致死锁之类的麻烦<br>ABA 问题，当 A 线程执行 2 的时候，被 B 线程更改了<em>p 为 x，而 C 线程又把它改回了<br>原始值，这时回到 A 线程，A 线程无法监测到原始值已经被更改过了，CAS 操作会成功（际上应该失败）。ABA 大部分情况下会造成一些问题，因为 p 的内容一般不可能是独立的，其他内容已经更改，而 A 线程认为它没有更改就会带来不可预知的结果。<br>如果开启 ATOMIC_FASTBINS 优化，这里的实现会出现 ABA 问题吗？不会出现，如果开启了 ATOMIC_FASTBINS 优化，在 free 时，如果释放的 chunk 属于 fast bin，不需要对分配区加锁，可以通过 lock-free 技术将该 chunk 加入 fast bins 的链表中。当从分配区分配内存时，需要对分配区加锁，所以当 A 线程获得了分配区的锁，并从 fast bin 中分配内存执行 2 的时候，被 B 线程调用 free 函数向 fast bin 的链表中加入了一个新的 chunk，即更改了</em>fb 为 x，但不会存在 C 线程将<em>fb 改回原值，如果存在，意味着 C 线程先分配了</em>fb 所存的 chunk，并将该 chunk 释放回了 fast bin，但 C 线程分配<em>fb 所存的 chunk 需要获得分配区的锁，但分配区的锁被 A 线程持有，所以 C 线程不可能将</em>fb 改回原值，也就不会存在 ABA 问题。（看看就得了）</p>
</li>
<li><p>如果所需的 chunk 大小属于 small bin，则会执行如下的代码：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;<span class="comment">/*如果nb的大小在small bin 的范围*/</span></span><br><span class="line">idx = smallbin_index(nb);<span class="comment">/*返回small bin 的index*/</span></span><br><span class="line">bin = bin_at(av,idx);<span class="comment">/*获得bin的地址*/</span></span><br><span class="line"><span class="keyword">if</span> ( (victim = last(bin)) != bin) &#123;<span class="comment">/*先从链表最后取一个chunk，用victim指向，如果这个chunk不是链表头，说明获得成功*/</span></span><br><span class="line"><span class="keyword">if</span> (victim == <span class="number">0</span>)<span class="comment">/*如果victim为零*/</span></span><br><span class="line"><span class="comment">/* initialization check </span></span><br><span class="line"><span class="comment">可能没有初始化*/</span></span><br><span class="line">malloc_consolidate(av);<span class="comment">/*将fast bin 中的chunk合并*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">/*victim != 0,说明取的是真chunk*/</span></span><br><span class="line">bck = victim-&gt;bk;<span class="comment">/*给局部变量赋值为前一个chunk的地址*/</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (bck-&gt;fd != victim, <span class="number">0</span>))<span class="comment">/*如果前一个chunk的下一个chunk不为当前所取的chunk*/</span></span><br><span class="line">&#123;<span class="comment">/*报错并退出*/</span></span><br><span class="line">errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">set_inuse_bit_at_offset(victim, nb);<span class="comment">/*设置chunk的inuse位（在物理相邻的下一个chunk的prev_size位哦）*/</span></span><br><span class="line">bin-&gt;bk = bck;<span class="comment">/*bin的bk赋值为bck（双向循环链表）*/</span></span><br><span class="line">bck-&gt;fd = bin;<span class="comment">/*bck指向chunk的fd指向bin*/</span></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)<span class="comment">/*如果不是主分配区*/</span></span><br><span class="line">victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">/*设置A位*/</span></span><br><span class="line">check_malloced_chunk(av, victim, nb);<span class="comment">/*debug用的，不管*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面和上面fast bin的一样，自己看吧*/</span></span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>如果所需的 chunk 不属于 small bins，首先会执行如下的代码段：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">idx = largebin_index(nb);<span class="comment">/*在large bin 中找到对应index*/</span></span><br><span class="line"><span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);<span class="comment">/*如果当前分配区fast bin中有fast chunk，将fast bin中chunk合并，并将合并后的chunk加入到unsorted bin中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下面的源代码实现从 last remainder chunk，large bins 和 top chunk 中分配所需的 chunk，这里包含了多个多层循环，在这些循环中，主要工作是分配前两步都未分配成功的 small binchunk，large bin chunk 和 large chunk。最外层的循环用于重新尝试分配 small bin chunk，因为如果在前一步分配 small bin chunk 不成功，并没有调用 malloc_consolidate()函数合并 fast bins 中的 chunk，将空闲 chunk 加入 unsorted bin 中，如果尝试从 last remainder chunk，top chunk 中分配 small bin chunk 都失败以后，如果 fast bins 中存在空闲 chunk，会调用malloc_consolidate()函数，那么在 usorted bin 中就可能存在合适的 small bin chunk 供分配，所以需要再次尝试。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line"><span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( (victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">chunk2mem (victim));</span><br><span class="line">size = chunksize(victim);</span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line"><span class="comment">/* split and reattach remainder */</span></span><br><span class="line">remainder_size = size - nb;</span><br><span class="line">remainder = chunk_at_offset(victim, nb);</span><br><span class="line">unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">av-&gt;last_remainder = remainder;</span><br><span class="line">remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line"> &#123;</span><br><span class="line">    remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">(av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot(remainder, remainder_size);</span><br><span class="line">check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">victim_index = smallbin_index(size);</span><br><span class="line">bck = bin_at(av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    victim_index = largebin_index(size);</span><br><span class="line">    bck = bin_at(av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line"><span class="comment">/* Or with inuse bit to speed comparisons */</span>    </span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line"><span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                &#123;</span><br><span class="line">                                        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line"><span class="comment">/* Always insert in the second position. */</span></span><br><span class="line">                    fwd = fwd-&gt;fd;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line">bck = fwd-&gt;bk;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line"><span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/cs_major/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="Limiter">
      <meta itemprop="description" content="maybe ordinary people don't always crack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1m1t3r's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/cs_major/" class="post-title-link" itemprop="url">CS作业预测及解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-16 13:17:38 / 修改时间：17:47:06" itemprop="dateCreated datePublished" datetime="2022-05-16T13:17:38+08:00">2022-05-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今年的预测难度可谓是大的离谱，当我看到x队，黑豹和小火苗这些强队被绿龙打的毫无换手之力时，我就知道这届比赛必定是爆冷连连。果不其然，失去了阿汤哥的NIP竟然开始发挥，3爷的狙也逐渐变得离谱，在加上小蜜蜂的疯狂拉跨，相信很多人的作业已经是接近凉凉。<br>不过好在navi依然稳的一比，直接3：0晋级（不会有人没选navi吧），让大多数人有了一丝机会。以下是剩余队伍的获胜概率分析，以及什么样的作业可以挺过这一轮恐怖的传奇组比赛。</p>
<h2 id="以下是我认为接下来比较可能晋级的队伍"><a href="#以下是我认为接下来比较可能晋级的队伍" class="headerlink" title="以下是我认为接下来比较可能晋级的队伍"></a>以下是我认为接下来比较可能晋级的队伍</h2><h3 id="X队（Heroic）"><a href="#X队（Heroic）" class="headerlink" title="X队（Heroic）"></a>X队（Heroic）</h3><p>最近几场比赛x队的发挥都一如既往的稳定，输给绿龙完全是因为绿龙发挥过于离谱，而且是bo1赛制，具有一定的运气成分。尼的步枪一直很刚，加上卡点也开始发挥，尤其是对战G2的比赛，在大比分落后且被G2先拿到赛点，以及处于打匪的劣势的情况下稳住心态，逐步反超，可见其无论是战术还是枪法心态都处于非常不错的状态。因此x队的晋级似乎是必然的。</p>
<h3 id="黑豹"><a href="#黑豹" class="headerlink" title="黑豹"></a>黑豹</h3><p>黑豹作为一支非常规战术以及个人能力都十分出色的战队，在传奇组的关键比赛中将要对战状态正好的NIP，NIP在对战navi之前可谓是风头极盛，但在与navi的比赛中被打击了一下。假如NIP的这次挫败并没有影响他们的火热手感，那么当前状态的黑豹是很难获胜的，除非arT和优瑞这两名大哥超常发挥，（尤其是arT）在非常规和干摸绕后中狠狠的偷NIP的屁股以打击他们的心态和手感。</p>
<h3 id="G2"><a href="#G2" class="headerlink" title="G2"></a>G2</h3><p>G2最近的两场落败都令人十分惋惜，无论是面对navi还是Heroic，都在jackz和表哥的发挥下打出了很大的优势，反观NIKO，已经很长时间没有发挥了，可以从NIKO多次的白给中发现其心态有些问题，似乎小李子的战术布局让NIKO的个人能力不能很好的发挥，并且在开局掉人或陷入劣势的情况下，NIKO希望凭借个人能力创造机会，从而更容易白给，使队友残局变得异常困难，我个人认为是monesy并没有完全弥补G2狙击手的短板，虽然年仅17岁的他操作犀利，上限极高，而且常常在残局1Vn，但在每局比赛中的开局打的过于稳建，在场上的站位也有些死板，并非是说monesy的实力和意识不足，从他的日常训练视频中可以看出他不逊色于s1mple的狙击技术和灵性。但在比赛时，过于年轻的monesy害怕由于自己的死亡而拖累队友，因此打的比较保守，反而在残局阶段和eco或强起时释放自我，往往打出逆天操作。今晚的G2对阵VP可以说只要G2不犯病或者被连续的失败打击了状态，基本是稳赢。但要想晋级，则需要和剩下的强队较量一番，以其实力来说是没有问题的，但G2的发挥和赛点犯病总是令人担忧。</p>
<h3 id="Faze"><a href="#Faze" class="headerlink" title="Faze"></a>Faze</h3><p>刚战胜的宿敌C9的Faze状态正好，只能说今晚战胜小火苗晋级是必然的事，选Faze是必然稳的（Faze输了的话就当我是sb）</p>
<h3 id="C9"><a href="#C9" class="headerlink" title="C9"></a>C9</h3><p>作为红星的躯壳，C9的复活似乎正是为了阻止Faze夺冠而来，无论是队伍实力还是情怀问题，选C9是不用犹豫的。</p>
<h3 id="NIP"><a href="#NIP" class="headerlink" title="NIP"></a>NIP</h3><p>NIP最近的发挥太离谱了，只能说他们不晋级的似乎是不可能的事情</p>
<h2 id="关于作业通过的概率"><a href="#关于作业通过的概率" class="headerlink" title="关于作业通过的概率"></a>关于作业通过的概率</h2><p>假如和我一样，在晋级队伍中选择了navi，G2，Faze，Heroic，黑豹，C9，小蜜蜂，<br>那么目前为止，navi已经成功晋级，小蜜蜂，G2和c9目前是1&#x2F;2的状态，G2的实力是很强的，若不是遇到navi状态正好，和自己的失误是不会沦落至此的，晋级的概率大概有60%，黑豹今晚不能晋级的话接下来就比较困难了，暂时算作50%概率晋级，Heroic和Faze还是比较稳的，即使失败，接下来对阵的队伍要么很拉，要么是已经选择的队伍，那么必定会有一支成功晋级，加上bNE 0&#x2F;3拯救无数人，如今仅仅需要3次竞猜成功就能及格，关键就在于今晚的比赛Faze，Heroic，黑豹三支队伍，只要有两只能成功晋级，那么及格就稳了，假如仅一支晋级，那么也有很大概率及格，如果三支队伍都晋级失败，那么就只能听天由命了。<br>希望他们不要辜负bNE给大家的机会</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="Limiter">
      <meta itemprop="description" content="maybe ordinary people don't always crack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1m1t3r's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/hello-world/" class="post-title-link" itemprop="url">welcome!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-16 13:00:03 / 修改时间：17:50:49" itemprop="dateCreated datePublished" datetime="2022-05-16T13:00:03+08:00">2022-05-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="水水水水水"><a href="#水水水水水" class="headerlink" title="水水水水水"></a>水水水水水</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Limiter"
      src="/images/doge.jpg">
  <p class="site-author-name" itemprop="name">Limiter</p>
  <div class="site-description" itemprop="description">maybe ordinary people don't always crack</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Limiter</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
